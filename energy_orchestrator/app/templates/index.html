<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Energy Orchestrator</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 1.5rem;
            background: #020617;
            color: #e5e7eb;
        }
        h1 { margin-top: 0; }
        h3 { margin-bottom: 0.5rem; }
        .card {
            background: #020617;
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #1f2937;
            max-width: 900px;
            margin-bottom: 1rem;
        }
        .action-btn {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 0.5rem;
            margin-right: 0.5rem;
            transition: background 0.2s;
        }
        .action-btn:hover {
            background: #2563eb;
        }
        .action-btn:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }
        .action-btn.secondary {
            background: #4b5563;
        }
        .action-btn.secondary:hover {
            background: #6b7280;
        }
        .action-btn.success {
            background: #059669;
        }
        .action-btn.success:hover {
            background: #047857;
        }
        .action-btn.warning {
            background: #d97706;
        }
        .action-btn.warning:hover {
            background: #b45309;
        }
        .status-message {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border-radius: 4px;
            display: none;
            font-size: 0.9rem;
            white-space: pre-wrap;
        }
        .status-message.success {
            background: #166534;
            color: #86efac;
            display: block;
        }
        .status-message.error {
            background: #991b1b;
            color: #fca5a5;
            display: block;
        }
        .status-message.loading {
            background: #1e3a8a;
            color: #93c5fd;
            display: block;
        }
        .status-message.info {
            background: #1e3a8a;
            color: #93c5fd;
            display: block;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .stat-item {
            background: #111827;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #9ca3af;
        }
        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
        }
        hr {
            border-color: #1f2937;
            margin: 1.5rem 0;
        }
        textarea {
            width: 100%;
            min-height: 150px;
            background: #111827;
            border: 1px solid #374151;
            border-radius: 8px;
            color: #e5e7eb;
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 0.85rem;
            padding: 0.75rem;
            resize: vertical;
            box-sizing: border-box;
        }
        textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        .results-table th, .results-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #374151;
        }
        .results-table th {
            background: #111827;
            color: #9ca3af;
            font-weight: 600;
        }
        .results-table tr:hover {
            background: #1f2937;
        }
        .chart-container {
            margin-top: 1rem;
            background: #111827;
            border-radius: 8px;
            padding: 1rem;
            min-height: 200px;
        }
        .bar {
            display: inline-block;
            background: #3b82f6;
            margin-right: 2px;
            vertical-align: bottom;
            border-radius: 2px 2px 0 0;
        }
        .chart-wrapper {
            display: flex;
            align-items: flex-end;
            height: 150px;
            border-bottom: 1px solid #374151;
            padding-bottom: 0.5rem;
        }
        .chart-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #9ca3af;
        }
        .sensor-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        .sensor-table th, .sensor-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #374151;
        }
        .sensor-table th {
            background: #111827;
            color: #9ca3af;
            font-weight: 600;
        }
        .total-kwh {
            font-size: 1.5rem;
            font-weight: 700;
            color: #22c55e;
            margin-top: 0.5rem;
        }
        .example-description {
            font-size: 0.85rem;
            color: #9ca3af;
            margin-bottom: 0.5rem;
        }
        .feature-category {
            margin-bottom: 1.5rem;
        }
        .feature-category-title {
            font-size: 1rem;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #374151;
        }
        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 0.5rem;
        }
        .feature-item {
            background: #111827;
            border-radius: 6px;
            padding: 0.75rem;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }
        .feature-item.core {
            border-left: 3px solid #22c55e;
        }
        .feature-item.experimental {
            border-left: 3px solid #f59e0b;
        }
        .feature-item.experimental.disabled {
            opacity: 0.6;
        }
        .feature-toggle {
            flex-shrink: 0;
            margin-top: 2px;
        }
        .feature-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .feature-toggle input[type="checkbox"]:disabled {
            cursor: not-allowed;
        }
        .feature-info {
            flex: 1;
            min-width: 0;
        }
        .feature-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: #e5e7eb;
        }
        .feature-badge {
            display: inline-block;
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
            font-weight: 500;
        }
        .feature-badge.core {
            background: #166534;
            color: #86efac;
        }
        .feature-badge.experimental {
            background: #78350f;
            color: #fcd34d;
        }
        .feature-description {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 0.25rem;
        }
        .feature-meta {
            font-size: 0.7rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        .timezone-config {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: #111827;
            border-radius: 8px;
        }
        .timezone-config label {
            font-weight: 500;
        }
        .timezone-config select {
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            color: #e5e7eb;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        .feature-stats {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: #111827;
            border-radius: 8px;
        }
        .feature-stat {
            text-align: center;
        }
        .feature-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #3b82f6;
        }
        .feature-stat-label {
            font-size: 0.75rem;
            color: #9ca3af;
        }
    </style>
</head>
<body>
    <h1>‚ö° Energy Orchestrator</h1>
    
    <div class="card">
        <p>Flask UI draait binnen Home Assistant.</p>
        <p><strong>Actuele windsnelheid:</strong>
            {{ wind_speed if wind_speed is not none else "onbekend" }}
        </p>
    </div>

    <div class="card">
        <h3>üîÑ Data Resampling</h3>
        <p>Resample raw sensor data into 5-minute time slots and save to resampled_samples table.</p>
        <button class="action-btn" id="resampleBtn" onclick="triggerResample()">Resample Data</button>
        <div id="resampleStatus" class="status-message"></div>
    </div>

    <div class="card">
        <h3>ü§ñ Model Training</h3>
        <p>Train the heating demand prediction model using resampled data.</p>
        <button class="action-btn success" id="trainBtn" onclick="trainModel()">Train Model</button>
        <button class="action-btn secondary" id="statusBtn" onclick="getModelStatus()">Check Status</button>
        <div id="modelStatus" class="status-message"></div>
    </div>

    <div class="card">
        <h3>üå°Ô∏è Scenario-Based Prediction (Simplified)</h3>
        <p class="example-description">Predict heating demand using simple, human-readable inputs. No need to calculate model features - just provide weather forecast and setpoint schedule.</p>
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 0.5rem;">
            <button class="action-btn secondary" id="loadScenarioExampleBtn" onclick="loadScenarioExample()">Load Example (24h)</button>
            <span style="color: #9ca3af;">or load from historical data:</span>
            <select id="historicalDaySelect" onchange="loadHistoricalDay()" style="background: #111827; border: 1px solid #374151; border-radius: 8px; color: #e5e7eb; padding: 0.5rem; cursor: pointer;">
                <option value="">Select historical day...</option>
            </select>
            <button class="action-btn secondary" id="refreshDaysBtn" onclick="loadAvailableDays()" style="padding: 0.5rem 1rem;">‚Üª</button>
        </div>
        <button class="action-btn success" id="runScenarioPredictionBtn" onclick="runScenarioPrediction()">Run Prediction</button>
        <p class="example-description" style="margin-top: 0.5rem;">Required per timeslot: timestamp (future), outdoor_temperature, wind_speed, humidity, pressure, target_temperature. Optional: indoor_temperature</p>
        <textarea id="scenarioInput" placeholder='{"timeslots": [{"timestamp": "2024-01-15T14:00:00", "outdoor_temperature": 5.0, "wind_speed": 3.0, "humidity": 75.0, "pressure": 1013.0, "target_temperature": 20.0}, ...]}'></textarea>
        <div id="scenarioStatus" class="status-message"></div>
        <div id="scenarioResult"></div>
    </div>

    <div class="card">
        <h3>üîÆ Single Slot Prediction</h3>
        <p class="example-description">Predict heating demand for a single 5-minute time slot.</p>
        <button class="action-btn secondary" id="loadSingleExampleBtn" onclick="loadSingleSlotExample()">Load Example</button>
        <button class="action-btn warning" id="runSinglePredictionBtn" onclick="runSingleSlotPrediction()">Run Prediction</button>
        <textarea id="singleSlotInput" placeholder='{"timeslots": ["2024-01-15T14:00:00"], "scenario_features": [{"outdoor_temp": 5.0, ...}]}'></textarea>
        <div id="singleSlotStatus" class="status-message"></div>
        <div id="singleSlotResult"></div>
    </div>

    <div class="card">
        <h3>üìÖ Full Day Prediction (24h)</h3>
        <p class="example-description">Predict heating demand for a complete day with hourly intervals.</p>
        <button class="action-btn secondary" id="loadDayExampleBtn" onclick="loadFullDayExample()">Load Example</button>
        <button class="action-btn warning" id="runDayPredictionBtn" onclick="runFullDayPrediction()">Run Prediction</button>
        <textarea id="fullDayInput" placeholder='{"timeslots": [...], "scenario_features": [...], "update_historical": true}'></textarea>
        <div id="fullDayStatus" class="status-message"></div>
        <div id="fullDayResult"></div>
    </div>

    <div class="card">
        <h3>‚öôÔ∏è Feature Configuration</h3>
        <p class="example-description">Configure which features are used for model training and prediction. Core features (13) are always active. Experimental features can be enabled/disabled.</p>
        <button class="action-btn secondary" id="loadFeaturesBtn" onclick="loadFeatureConfig()">Load Configuration</button>
        <div id="featureConfigStatus" class="status-message"></div>
        <div id="featureConfigContent"></div>
    </div>

    <div class="card">
        <h3>üìä Sensor Information</h3>
        <p>View first and last timestamp for each sensor in the database.</p>
        <button class="action-btn secondary" id="loadSensorsBtn" onclick="loadSensorInfo()">Load Sensor Info</button>
        <div id="sensorInfoStatus" class="status-message"></div>
        <div id="sensorInfoTable"></div>
    </div>

    <script>
        // Store historical data when loaded for comparison in table
        let currentHistoricalData = null;
        
        // Load available days on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadAvailableDays();
        });
        
        async function loadAvailableDays() {
            const select = document.getElementById('historicalDaySelect');
            
            try {
                const response = await fetch('api/examples/available_days');
                const data = await response.json();
                
                // Clear existing options except first
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                if (response.ok && data.days && data.days.length > 0) {
                    data.days.forEach(day => {
                        const option = document.createElement('option');
                        option.value = day;
                        option.textContent = day;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading available days:', error);
            }
        }
        
        async function loadHistoricalDay() {
            const select = document.getElementById('historicalDaySelect');
            const selectedDay = select.value;
            
            if (!selectedDay) {
                currentHistoricalData = null;
                return;
            }
            
            const statusDiv = document.getElementById('scenarioStatus');
            const textarea = document.getElementById('scenarioInput');
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading historical data for ' + selectedDay + '...';
            
            try {
                const response = await fetch('api/examples/historical_day/' + selectedDay);
                const data = await response.json();
                
                if (response.ok) {
                    // Store historical data for comparison
                    currentHistoricalData = data.hourly_data;
                    
                    // Load scenario format into textarea
                    textarea.value = JSON.stringify(data.scenario_format, null, 2);
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Loaded historical data for ' + selectedDay + '. Run prediction to compare model output with actual data.';
                    
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    currentHistoricalData = null;
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                currentHistoricalData = null;
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        async function triggerResample() {
            const btn = document.getElementById('resampleBtn');
            const statusDiv = document.getElementById('resampleStatus');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Resampling in progress...';
            
            try {
                const response = await fetch('resample', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const stats = data.stats || {};
                    let message = '‚úì ' + data.message + '\n\n';
                    message += 'Slots processed: ' + (stats.slots_processed || 0) + '\n';
                    message += 'Slots saved: ' + (stats.slots_saved || 0) + '\n';
                    message += 'Slots skipped: ' + (stats.slots_skipped || 0) + '\n';
                    if (stats.categories && stats.categories.length > 0) {
                        message += 'Categories: ' + stats.categories.join(', ') + '\n';
                    }
                    if (stats.start_time) {
                        message += 'Time range: ' + stats.start_time + ' to ' + stats.end_time;
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function trainModel() {
            const btn = document.getElementById('trainBtn');
            const statusDiv = document.getElementById('modelStatus');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Training model... This may take a while.';
            
            try {
                const response = await fetch('api/train/heating_demand', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const metrics = data.metrics || {};
                    const stats = data.dataset_stats || {};
                    let message = '‚úì ' + data.message + '\n\n';
                    message += 'Training samples: ' + (metrics.train_samples || 0) + '\n';
                    message += 'Validation samples: ' + (metrics.val_samples || 0) + '\n';
                    message += 'Train MAE (kWh): ' + (metrics.train_mae_kwh || 'N/A') + '\n';
                    message += 'Val MAE (kWh): ' + (metrics.val_mae_kwh || 'N/A') + '\n';
                    message += 'Val MAPE (%): ' + (metrics.val_mape_pct || 'N/A') + '\n';
                    message += 'Val R¬≤: ' + (metrics.val_r2 || 'N/A') + '\n';
                    if (metrics.features && metrics.features.length > 0) {
                        message += '\nFeatures: ' + metrics.features.join(', ');
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                } else {
                    let message = '‚úó ' + (data.message || 'Training failed');
                    if (data.stats) {
                        message += '\n\nDataset stats:';
                        message += '\nTotal slots: ' + (data.stats.total_slots || 0);
                        message += '\nValid slots: ' + (data.stats.valid_slots || 0);
                    }
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function getModelStatus() {
            const btn = document.getElementById('statusBtn');
            const statusDiv = document.getElementById('modelStatus');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Checking model status...';
            
            try {
                const response = await fetch('api/model/status');
                const data = await response.json();
                
                if (data.status === 'available') {
                    let message = '‚úì Model is available\n\n';
                    message += 'Training timestamp: ' + (data.training_timestamp || 'Unknown') + '\n';
                    if (data.features && data.features.length > 0) {
                        message += 'Features: ' + data.features.join(', ');
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                } else {
                    statusDiv.className = 'status-message info';
                    statusDiv.textContent = '‚ÑπÔ∏è ' + (data.message || 'No model available');
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadSingleSlotExample() {
            const btn = document.getElementById('loadSingleExampleBtn');
            const statusDiv = document.getElementById('singleSlotStatus');
            const textarea = document.getElementById('singleSlotInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading example...';
            
            try {
                const response = await fetch('api/examples/single_slot');
                const data = await response.json();
                
                if (response.ok) {
                    textarea.value = JSON.stringify(data.example, null, 2);
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.description;
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function runSingleSlotPrediction() {
            const btn = document.getElementById('runSinglePredictionBtn');
            const statusDiv = document.getElementById('singleSlotStatus');
            const resultDiv = document.getElementById('singleSlotResult');
            const textarea = document.getElementById('singleSlotInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Running prediction...';
            resultDiv.innerHTML = '';
            
            try {
                const requestData = JSON.parse(textarea.value);
                
                const response = await fetch('api/predictions/heating_demand_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Prediction completed successfully';
                    
                    // Display result as table
                    let html = '<table class="results-table"><thead><tr><th>Time Slot</th><th>Predicted kWh</th></tr></thead><tbody>';
                    const timeslots = data.timeslots || requestData.timeslots || [];
                    data.predictions.forEach((pred, idx) => {
                        const slot = timeslots[idx] || `Slot ${idx + 1}`;
                        html += `<tr><td>${slot}</td><td>${pred.toFixed(4)}</td></tr>`;
                    });
                    html += '</tbody></table>';
                    html += `<div class="total-kwh">Total: ${data.total_kwh.toFixed(4)} kWh</div>`;
                    resultDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    let message = '‚úó ' + data.message;
                    if (data.required_features) {
                        message += '\n\nRequired features: ' + data.required_features.join(', ');
                    }
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadFullDayExample() {
            const btn = document.getElementById('loadDayExampleBtn');
            const statusDiv = document.getElementById('fullDayStatus');
            const textarea = document.getElementById('fullDayInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading example...';
            
            try {
                const response = await fetch('api/examples/full_day');
                const data = await response.json();
                
                if (response.ok) {
                    textarea.value = JSON.stringify(data.example, null, 2);
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.description;
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function runFullDayPrediction() {
            const btn = document.getElementById('runDayPredictionBtn');
            const statusDiv = document.getElementById('fullDayStatus');
            const resultDiv = document.getElementById('fullDayResult');
            const textarea = document.getElementById('fullDayInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Running prediction...';
            resultDiv.innerHTML = '';
            
            try {
                const requestData = JSON.parse(textarea.value);
                
                const response = await fetch('api/predictions/heating_demand_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Prediction completed successfully';
                    
                    // Display result as chart and table
                    const predictions = data.predictions;
                    const maxVal = Math.max(...predictions, 0.1);
                    const timeslots = data.timeslots || requestData.timeslots || [];
                    
                    // Create simple bar chart
                    let chartHtml = '<div class="chart-container"><h4 style="margin-top:0">Hourly Heating Demand</h4>';
                    chartHtml += '<div class="chart-wrapper">';
                    predictions.forEach((pred, idx) => {
                        const height = (pred / maxVal) * 100;
                        const width = Math.max(100 / predictions.length - 1, 5);
                        chartHtml += `<div class="bar" style="height: ${height}%; width: ${width}%" title="${timeslots[idx] || 'Hour ' + idx}: ${pred.toFixed(3)} kWh"></div>`;
                    });
                    chartHtml += '</div>';
                    chartHtml += '<div class="chart-labels">';
                    chartHtml += `<span>00:00</span><span>06:00</span><span>12:00</span><span>18:00</span><span>24:00</span>`;
                    chartHtml += '</div></div>';
                    
                    // Create table
                    chartHtml += '<table class="results-table"><thead><tr><th>Time Slot</th><th>Predicted kWh</th></tr></thead><tbody>';
                    predictions.forEach((pred, idx) => {
                        const slot = timeslots[idx] || `Slot ${idx + 1}`;
                        chartHtml += `<tr><td>${slot}</td><td>${pred.toFixed(4)}</td></tr>`;
                    });
                    chartHtml += '</tbody></table>';
                    chartHtml += `<div class="total-kwh">Total Daily Consumption: ${data.total_kwh.toFixed(4)} kWh</div>`;
                    
                    resultDiv.innerHTML = chartHtml;
                } else {
                    statusDiv.className = 'status-message error';
                    let message = '‚úó ' + data.message;
                    if (data.required_features) {
                        message += '\n\nRequired features: ' + data.required_features.join(', ');
                    }
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadSensorInfo() {
            const btn = document.getElementById('loadSensorsBtn');
            const statusDiv = document.getElementById('sensorInfoStatus');
            const tableDiv = document.getElementById('sensorInfoTable');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading sensor information...';
            tableDiv.innerHTML = '';
            
            try {
                const response = await fetch('api/sensors/info');
                const data = await response.json();
                
                if (response.ok && data.sensors && data.sensors.length > 0) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Found ${data.count} sensors`;
                    
                    let html = '<table class="sensor-table"><thead><tr>';
                    html += '<th>Entity ID</th><th>First Timestamp</th><th>Last Timestamp</th><th>Sample Count</th>';
                    html += '</tr></thead><tbody>';
                    
                    data.sensors.forEach(sensor => {
                        html += `<tr>`;
                        html += `<td>${sensor.entity_id}</td>`;
                        html += `<td>${sensor.first_timestamp || 'N/A'}</td>`;
                        html += `<td>${sensor.last_timestamp || 'N/A'}</td>`;
                        html += `<td>${sensor.sample_count.toLocaleString()}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += '</tbody></table>';
                    tableDiv.innerHTML = html;
                } else if (response.ok) {
                    statusDiv.className = 'status-message info';
                    statusDiv.textContent = '‚ÑπÔ∏è No sensors found in database';
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadScenarioExample() {
            const btn = document.getElementById('loadScenarioExampleBtn');
            const statusDiv = document.getElementById('scenarioStatus');
            const textarea = document.getElementById('scenarioInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading example...';
            
            try {
                const response = await fetch('api/examples/scenario');
                const data = await response.json();
                
                if (response.ok) {
                    textarea.value = JSON.stringify(data.example, null, 2);
                    // Clear historical data when loading example
                    currentHistoricalData = null;
                    document.getElementById('historicalDaySelect').value = '';
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.description;
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function runScenarioPrediction() {
            const btn = document.getElementById('runScenarioPredictionBtn');
            const statusDiv = document.getElementById('scenarioStatus');
            const resultDiv = document.getElementById('scenarioResult');
            const textarea = document.getElementById('scenarioInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Running prediction...';
            resultDiv.innerHTML = '';
            
            try {
                const requestData = JSON.parse(textarea.value);
                
                const response = await fetch('api/predictions/scenario', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    let statusText = '‚úì Prediction completed successfully - ' + data.slots_count + ' timeslots processed';
                    if (currentHistoricalData) {
                        statusText += ' (comparing with actual historical data)';
                    }
                    statusDiv.textContent = statusText;
                    
                    const predictions = data.predictions;
                    const predValues = predictions.map(p => p.predicted_kwh);
                    
                    // Helper function to extract hour key from timestamp
                    function getHourKey(timestamp) {
                        if (!timestamp || typeof timestamp !== 'string') return null;
                        const tIndex = timestamp.indexOf('T');
                        if (tIndex === -1) return null;
                        const timePart = timestamp.substring(tIndex + 1);
                        if (timePart.length < 5) return null;
                        return timePart.substring(0, 5);
                    }
                    
                    // Get actual values if historical data is available
                    let actualValues = [];
                    let hasComparison = false;
                    if (currentHistoricalData && currentHistoricalData.length > 0) {
                        // Build lookup by hour for comparison
                        const actualByHour = {};
                        currentHistoricalData.forEach(h => {
                            const hourKey = getHourKey(h.timestamp);
                            if (hourKey !== null) {
                                actualByHour[hourKey] = h.actual_heating_kwh;
                            }
                        });
                        
                        predictions.forEach(p => {
                            const hourKey = getHourKey(p.timestamp);
                            actualValues.push(hourKey !== null && actualByHour[hourKey] !== undefined ? actualByHour[hourKey] : null);
                        });
                        hasComparison = actualValues.some(v => v !== null && v !== undefined);
                    }
                    
                    const maxPred = Math.max(...predValues, 0.1);
                    const filteredActuals = actualValues.filter(v => v !== null && v !== undefined);
                    const maxActual = hasComparison && filteredActuals.length > 0 ? Math.max(...filteredActuals, 0.1) : 0;
                    const maxVal = Math.max(maxPred, maxActual, 0.1);
                    
                    // Create bar chart with comparison if available
                    let chartHtml = '<div class="chart-container"><h4 style="margin-top:0">Hourly Heating Demand' + (hasComparison ? ' (Predicted vs Actual)' : '') + '</h4>';
                    if (hasComparison) {
                        chartHtml += '<div style="margin-bottom: 0.5rem; font-size: 0.85rem;"><span style="color: #3b82f6;">‚ñ† Predicted</span> <span style="color: #22c55e; margin-left: 1rem;">‚ñ† Actual</span></div>';
                    }
                    chartHtml += '<div class="chart-wrapper">';
                    predictions.forEach((pred, idx) => {
                        const predHeight = (pred.predicted_kwh / maxVal) * 100;
                        const width = Math.max(100 / predictions.length / (hasComparison ? 2 : 1) - 1, 3);
                        chartHtml += `<div class="bar" style="height: ${predHeight}%; width: ${width}%; background: #3b82f6;" title="${pred.timestamp}: ${pred.predicted_kwh.toFixed(3)} kWh (predicted)"></div>`;
                        
                        if (hasComparison && actualValues[idx] !== null && actualValues[idx] !== undefined) {
                            const actualHeight = (actualValues[idx] / maxVal) * 100;
                            chartHtml += `<div class="bar" style="height: ${actualHeight}%; width: ${width}%; background: #22c55e;" title="${pred.timestamp}: ${actualValues[idx].toFixed(3)} kWh (actual)"></div>`;
                        }
                    });
                    chartHtml += '</div>';
                    chartHtml += '<div class="chart-labels">';
                    if (predictions.length >= 4) {
                        const step = Math.floor(predictions.length / 4);
                        chartHtml += `<span>${predictions[0].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step*2].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step*3].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[predictions.length-1].timestamp.split('T')[1]}</span>`;
                    }
                    chartHtml += '</div></div>';
                    
                    // Create table with comparison column if available
                    if (hasComparison) {
                        chartHtml += '<table class="results-table"><thead><tr><th>Timestamp</th><th>Predicted kWh</th><th>Actual kWh</th><th>Œî (kWh)</th><th>Œî (%)</th></tr></thead><tbody>';
                        let totalActual = 0;
                        let totalDelta = 0;
                        let countCompared = 0;
                        predictions.forEach((pred, idx) => {
                            const actual = actualValues[idx];
                            const hasActual = actual !== null && actual !== undefined;
                            const delta = hasActual ? pred.predicted_kwh - actual : null;
                            const deltaPct = hasActual && actual > 0.01 ? (delta / actual * 100) : null;
                            
                            if (hasActual) {
                                totalActual += actual;
                                totalDelta += Math.abs(delta);
                                countCompared++;
                            }
                            
                            const deltaClass = delta !== null ? (delta > 0 ? 'color: #f87171;' : 'color: #4ade80;') : '';
                            
                            chartHtml += `<tr>`;
                            chartHtml += `<td>${pred.timestamp}</td>`;
                            chartHtml += `<td>${pred.predicted_kwh.toFixed(4)}</td>`;
                            chartHtml += `<td>${hasActual ? actual.toFixed(4) : '-'}</td>`;
                            chartHtml += `<td style="${deltaClass}">${delta !== null ? (delta > 0 ? '+' : '') + delta.toFixed(4) : '-'}</td>`;
                            chartHtml += `<td style="${deltaClass}">${deltaPct !== null ? (deltaPct > 0 ? '+' : '') + deltaPct.toFixed(1) + '%' : '-'}</td>`;
                            chartHtml += `</tr>`;
                        });
                        chartHtml += '</tbody></table>';
                        
                        // Summary statistics
                        const mae = countCompared > 0 ? totalDelta / countCompared : 0;
                        const mape = countCompared > 0 && totalActual > 0 ? (totalDelta / totalActual * 100) : null;
                        
                        chartHtml += `<div style="display: flex; gap: 2rem; margin-top: 1rem;">`;
                        chartHtml += `<div class="total-kwh">Predicted Total: ${data.total_kwh.toFixed(4)} kWh</div>`;
                        chartHtml += `<div class="total-kwh" style="color: #22c55e;">Actual Total: ${totalActual.toFixed(4)} kWh</div>`;
                        chartHtml += `</div>`;
                        chartHtml += `<div style="margin-top: 0.5rem; color: #9ca3af; font-size: 0.9rem;">`;
                        chartHtml += `Mean Absolute Error: ${mae.toFixed(4)} kWh`;
                        if (mape !== null) {
                            chartHtml += ` | MAPE: ${mape.toFixed(1)}%`;
                        }
                        chartHtml += `</div>`;
                    } else {
                        chartHtml += '<table class="results-table"><thead><tr><th>Timestamp</th><th>Predicted kWh</th></tr></thead><tbody>';
                        predictions.forEach(pred => {
                            chartHtml += `<tr><td>${pred.timestamp}</td><td>${pred.predicted_kwh.toFixed(4)}</td></tr>`;
                        });
                        chartHtml += '</tbody></table>';
                        chartHtml += `<div class="total-kwh">Total Consumption: ${data.total_kwh.toFixed(4)} kWh</div>`;
                    }
                    
                    resultDiv.innerHTML = chartHtml;
                } else {
                    statusDiv.className = 'status-message error';
                    let message = '‚úó ' + data.message;
                    if (data.errors && data.errors.length > 0) {
                        message += '\n\nErrors:\n' + data.errors.join('\n');
                    }
                    if (data.required_fields) {
                        message += '\n\nRequired fields: ' + data.required_fields.join(', ');
                    }
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadFeatureConfig() {
            const btn = document.getElementById('loadFeaturesBtn');
            const statusDiv = document.getElementById('featureConfigStatus');
            const contentDiv = document.getElementById('featureConfigContent');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading feature configuration...';
            
            try {
                const response = await fetch('api/features/config');
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Configuration loaded: ${data.config.active_feature_count} active features (${data.config.core_feature_count} core + ${data.config.active_feature_count - data.config.core_feature_count} experimental)`;
                    
                    // Build UI
                    let html = '';
                    
                    // Feature stats
                    html += '<div class="feature-stats">';
                    html += `<div class="feature-stat"><div class="feature-stat-value">${data.config.core_feature_count}</div><div class="feature-stat-label">Core Features</div></div>`;
                    html += `<div class="feature-stat"><div class="feature-stat-value">${data.config.active_feature_count}</div><div class="feature-stat-label">Active Features</div></div>`;
                    html += '</div>';
                    
                    // Timezone configuration
                    html += '<div class="timezone-config">';
                    html += '<label for="timezoneSelect">üïê Timezone for hour_of_day:</label>';
                    html += `<select id="timezoneSelect" onchange="updateTimezone(this.value)">`;
                    const commonTimezones = [
                        'Europe/Amsterdam', 'Europe/London', 'Europe/Paris', 'Europe/Berlin',
                        'America/New_York', 'America/Chicago', 'America/Denver', 'America/Los_Angeles',
                        'Asia/Tokyo', 'Asia/Shanghai', 'Australia/Sydney', 'UTC'
                    ];
                    commonTimezones.forEach(tz => {
                        const selected = tz === data.config.timezone ? 'selected' : '';
                        html += `<option value="${tz}" ${selected}>${tz}</option>`;
                    });
                    html += '</select>';
                    html += '</div>';
                    
                    // Category order
                    const categoryOrder = ['weather', 'indoor', 'control', 'usage', 'time'];
                    const categoryIcons = {
                        'weather': 'üå§Ô∏è',
                        'indoor': 'üè†',
                        'control': 'üéõÔ∏è',
                        'usage': '‚ö°',
                        'time': 'üïê'
                    };
                    
                    // Features by category
                    categoryOrder.forEach(category => {
                        const features = data.features[category] || [];
                        if (features.length === 0) return;
                        
                        html += '<div class="feature-category">';
                        html += `<div class="feature-category-title">${categoryIcons[category] || 'üìå'} ${category.charAt(0).toUpperCase() + category.slice(1)}</div>`;
                        html += '<div class="feature-list">';
                        
                        features.forEach(f => {
                            const itemClass = f.is_core ? 'core' : (f.enabled ? 'experimental' : 'experimental disabled');
                            const badgeClass = f.is_core ? 'core' : 'experimental';
                            const badgeText = f.is_core ? 'CORE' : 'EXPERIMENTAL';
                            const checked = f.enabled ? 'checked' : '';
                            const disabled = f.is_core ? 'disabled' : '';
                            
                            html += `<div class="feature-item ${itemClass}">`;
                            html += `<div class="feature-toggle"><input type="checkbox" ${checked} ${disabled} onchange="toggleFeature('${f.name}', this.checked)"></div>`;
                            html += `<div class="feature-info">`;
                            html += `<div class="feature-name">${f.name}<span class="feature-badge ${badgeClass}">${badgeText}</span></div>`;
                            html += `<div class="feature-description">${f.description}</div>`;
                            html += `<div class="feature-meta">Unit: ${f.unit}${f.time_window !== 'none' ? ' | Window: ' + f.time_window : ''}</div>`;
                            html += `</div>`;
                            html += `</div>`;
                        });
                        
                        html += '</div>';
                        html += '</div>';
                    });
                    
                    contentDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function toggleFeature(featureName, enabled) {
            const statusDiv = document.getElementById('featureConfigStatus');
            
            try {
                const response = await fetch('api/features/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        feature_name: featureName,
                        enabled: enabled
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    // Reload to update stats
                    loadFeatureConfig();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    // Reload to restore checkbox state
                    loadFeatureConfig();
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                loadFeatureConfig();
            }
        }

        async function updateTimezone(timezone) {
            const statusDiv = document.getElementById('featureConfigStatus');
            
            try {
                const response = await fetch('api/features/timezone', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timezone: timezone })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    loadFeatureConfig();
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                loadFeatureConfig();
            }
        }
    </script>
</body>
</html>
