<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Energy Orchestrator</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 1.5rem;
            background: #020617;
            color: #e5e7eb;
        }
        h1 { margin-top: 0; }
        h3 { margin-bottom: 0.5rem; }
        .card {
            background: #020617;
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #1f2937;
            max-width: 900px;
            margin-bottom: 1rem;
        }
        .action-btn {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 0.5rem;
            margin-right: 0.5rem;
            transition: background 0.2s;
        }
        .action-btn:hover {
            background: #2563eb;
        }
        .action-btn:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }
        .action-btn.secondary {
            background: #4b5563;
        }
        .action-btn.secondary:hover {
            background: #6b7280;
        }
        .action-btn.success {
            background: #059669;
        }
        .action-btn.success:hover {
            background: #047857;
        }
        .action-btn.warning {
            background: #d97706;
        }
        .action-btn.warning:hover {
            background: #b45309;
        }
        .status-message {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border-radius: 4px;
            display: none;
            font-size: 0.9rem;
            white-space: pre-wrap;
        }
        .status-message.success {
            background: #166534;
            color: #86efac;
            display: block;
        }
        .status-message.error {
            background: #991b1b;
            color: #fca5a5;
            display: block;
        }
        .status-message.loading {
            background: #1e3a8a;
            color: #93c5fd;
            display: block;
        }
        .status-message.info {
            background: #1e3a8a;
            color: #93c5fd;
            display: block;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .stat-item {
            background: #111827;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #9ca3af;
        }
        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
        }
        hr {
            border-color: #1f2937;
            margin: 1.5rem 0;
        }
        textarea {
            width: 100%;
            min-height: 150px;
            background: #111827;
            border: 1px solid #374151;
            border-radius: 8px;
            color: #e5e7eb;
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 0.85rem;
            padding: 0.75rem;
            resize: vertical;
            box-sizing: border-box;
        }
        textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        .results-table th, .results-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #374151;
        }
        .results-table th {
            background: #111827;
            color: #9ca3af;
            font-weight: 600;
        }
        .results-table tr:hover {
            background: #1f2937;
        }
        .chart-container {
            margin-top: 1rem;
            background: #111827;
            border-radius: 8px;
            padding: 1rem;
            min-height: 200px;
        }
        .bar {
            display: inline-block;
            background: #3b82f6;
            margin-right: 2px;
            vertical-align: bottom;
            border-radius: 2px 2px 0 0;
        }
        .chart-wrapper {
            display: flex;
            align-items: flex-end;
            height: 150px;
            border-bottom: 1px solid #374151;
            padding-bottom: 0.5rem;
        }
        .chart-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #9ca3af;
        }
        .sensor-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        .sensor-table th, .sensor-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #374151;
        }
        .sensor-table th {
            background: #111827;
            color: #9ca3af;
            font-weight: 600;
        }
        .total-kwh {
            font-size: 1.5rem;
            font-weight: 700;
            color: #22c55e;
            margin-top: 0.5rem;
        }
        .example-description {
            font-size: 0.85rem;
            color: #9ca3af;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <h1>‚ö° Energy Orchestrator</h1>
    
    <div class="card">
        <p>Flask UI draait binnen Home Assistant.</p>
        <p><strong>Actuele windsnelheid:</strong>
            {{ wind_speed if wind_speed is not none else "onbekend" }}
        </p>
    </div>

    <div class="card">
        <h3>üîÑ Data Resampling</h3>
        <p>Resample raw sensor data into 5-minute time slots and save to resampled_samples table.</p>
        <button class="action-btn" id="resampleBtn" onclick="triggerResample()">Resample Data</button>
        <div id="resampleStatus" class="status-message"></div>
    </div>

    <div class="card">
        <h3>ü§ñ Model Training</h3>
        <p>Train the heating demand prediction model using resampled data.</p>
        <button class="action-btn success" id="trainBtn" onclick="trainModel()">Train Model</button>
        <button class="action-btn secondary" id="statusBtn" onclick="getModelStatus()">Check Status</button>
        <div id="modelStatus" class="status-message"></div>
    </div>

    <div class="card">
        <h3>üå°Ô∏è Scenario-Based Prediction (Simplified)</h3>
        <p class="example-description">Predict heating demand using simple, human-readable inputs. No need to calculate model features - just provide weather forecast and setpoint schedule.</p>
        <button class="action-btn secondary" id="loadScenarioExampleBtn" onclick="loadScenarioExample()">Load Example (24h)</button>
        <button class="action-btn success" id="runScenarioPredictionBtn" onclick="runScenarioPrediction()">Run Prediction</button>
        <p class="example-description" style="margin-top: 0.5rem;">Required per timeslot: timestamp (future), outdoor_temperature, wind_speed, humidity, pressure, target_temperature. Optional: indoor_temperature</p>
        <textarea id="scenarioInput" placeholder='{"timeslots": [{"timestamp": "2024-01-15T14:00:00", "outdoor_temperature": 5.0, "wind_speed": 3.0, "humidity": 75.0, "pressure": 1013.0, "target_temperature": 20.0}, ...]}'></textarea>
        <div id="scenarioStatus" class="status-message"></div>
        <div id="scenarioResult"></div>
    </div>

    <div class="card">
        <h3>üîÆ Single Slot Prediction</h3>
        <p class="example-description">Predict heating demand for a single 5-minute time slot.</p>
        <button class="action-btn secondary" id="loadSingleExampleBtn" onclick="loadSingleSlotExample()">Load Example</button>
        <button class="action-btn warning" id="runSinglePredictionBtn" onclick="runSingleSlotPrediction()">Run Prediction</button>
        <textarea id="singleSlotInput" placeholder='{"timeslots": ["2024-01-15T14:00:00"], "scenario_features": [{"outdoor_temp": 5.0, ...}]}'></textarea>
        <div id="singleSlotStatus" class="status-message"></div>
        <div id="singleSlotResult"></div>
    </div>

    <div class="card">
        <h3>üìÖ Full Day Prediction (24h)</h3>
        <p class="example-description">Predict heating demand for a complete day with hourly intervals.</p>
        <button class="action-btn secondary" id="loadDayExampleBtn" onclick="loadFullDayExample()">Load Example</button>
        <button class="action-btn warning" id="runDayPredictionBtn" onclick="runFullDayPrediction()">Run Prediction</button>
        <textarea id="fullDayInput" placeholder='{"timeslots": [...], "scenario_features": [...], "update_historical": true}'></textarea>
        <div id="fullDayStatus" class="status-message"></div>
        <div id="fullDayResult"></div>
    </div>

    <div class="card">
        <h3>üìä Sensor Information</h3>
        <p>View first and last timestamp for each sensor in the database.</p>
        <button class="action-btn secondary" id="loadSensorsBtn" onclick="loadSensorInfo()">Load Sensor Info</button>
        <div id="sensorInfoStatus" class="status-message"></div>
        <div id="sensorInfoTable"></div>
    </div>

    <script>
        async function triggerResample() {
            const btn = document.getElementById('resampleBtn');
            const statusDiv = document.getElementById('resampleStatus');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Resampling in progress...';
            
            try {
                const response = await fetch('resample', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const stats = data.stats || {};
                    let message = '‚úì ' + data.message + '\n\n';
                    message += 'Slots processed: ' + (stats.slots_processed || 0) + '\n';
                    message += 'Slots saved: ' + (stats.slots_saved || 0) + '\n';
                    message += 'Slots skipped: ' + (stats.slots_skipped || 0) + '\n';
                    if (stats.categories && stats.categories.length > 0) {
                        message += 'Categories: ' + stats.categories.join(', ') + '\n';
                    }
                    if (stats.start_time) {
                        message += 'Time range: ' + stats.start_time + ' to ' + stats.end_time;
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function trainModel() {
            const btn = document.getElementById('trainBtn');
            const statusDiv = document.getElementById('modelStatus');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Training model... This may take a while.';
            
            try {
                const response = await fetch('api/train/heating_demand', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const metrics = data.metrics || {};
                    const stats = data.dataset_stats || {};
                    let message = '‚úì ' + data.message + '\n\n';
                    message += 'Training samples: ' + (metrics.train_samples || 0) + '\n';
                    message += 'Validation samples: ' + (metrics.val_samples || 0) + '\n';
                    message += 'Train MAE (kWh): ' + (metrics.train_mae_kwh || 'N/A') + '\n';
                    message += 'Val MAE (kWh): ' + (metrics.val_mae_kwh || 'N/A') + '\n';
                    message += 'Val MAPE (%): ' + (metrics.val_mape_pct || 'N/A') + '\n';
                    message += 'Val R¬≤: ' + (metrics.val_r2 || 'N/A') + '\n';
                    if (metrics.features && metrics.features.length > 0) {
                        message += '\nFeatures: ' + metrics.features.join(', ');
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                } else {
                    let message = '‚úó ' + (data.message || 'Training failed');
                    if (data.stats) {
                        message += '\n\nDataset stats:';
                        message += '\nTotal slots: ' + (data.stats.total_slots || 0);
                        message += '\nValid slots: ' + (data.stats.valid_slots || 0);
                    }
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function getModelStatus() {
            const btn = document.getElementById('statusBtn');
            const statusDiv = document.getElementById('modelStatus');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Checking model status...';
            
            try {
                const response = await fetch('api/model/status');
                const data = await response.json();
                
                if (data.status === 'available') {
                    let message = '‚úì Model is available\n\n';
                    message += 'Training timestamp: ' + (data.training_timestamp || 'Unknown') + '\n';
                    if (data.features && data.features.length > 0) {
                        message += 'Features: ' + data.features.join(', ');
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                } else {
                    statusDiv.className = 'status-message info';
                    statusDiv.textContent = '‚ÑπÔ∏è ' + (data.message || 'No model available');
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadSingleSlotExample() {
            const btn = document.getElementById('loadSingleExampleBtn');
            const statusDiv = document.getElementById('singleSlotStatus');
            const textarea = document.getElementById('singleSlotInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading example...';
            
            try {
                const response = await fetch('api/examples/single_slot');
                const data = await response.json();
                
                if (response.ok) {
                    textarea.value = JSON.stringify(data.example, null, 2);
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.description;
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function runSingleSlotPrediction() {
            const btn = document.getElementById('runSinglePredictionBtn');
            const statusDiv = document.getElementById('singleSlotStatus');
            const resultDiv = document.getElementById('singleSlotResult');
            const textarea = document.getElementById('singleSlotInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Running prediction...';
            resultDiv.innerHTML = '';
            
            try {
                const requestData = JSON.parse(textarea.value);
                
                const response = await fetch('api/predictions/heating_demand_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Prediction completed successfully';
                    
                    // Display result as table
                    let html = '<table class="results-table"><thead><tr><th>Time Slot</th><th>Predicted kWh</th></tr></thead><tbody>';
                    const timeslots = data.timeslots || requestData.timeslots || [];
                    data.predictions.forEach((pred, idx) => {
                        const slot = timeslots[idx] || `Slot ${idx + 1}`;
                        html += `<tr><td>${slot}</td><td>${pred.toFixed(4)}</td></tr>`;
                    });
                    html += '</tbody></table>';
                    html += `<div class="total-kwh">Total: ${data.total_kwh.toFixed(4)} kWh</div>`;
                    resultDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    let message = '‚úó ' + data.message;
                    if (data.required_features) {
                        message += '\n\nRequired features: ' + data.required_features.join(', ');
                    }
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadFullDayExample() {
            const btn = document.getElementById('loadDayExampleBtn');
            const statusDiv = document.getElementById('fullDayStatus');
            const textarea = document.getElementById('fullDayInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading example...';
            
            try {
                const response = await fetch('api/examples/full_day');
                const data = await response.json();
                
                if (response.ok) {
                    textarea.value = JSON.stringify(data.example, null, 2);
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.description;
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function runFullDayPrediction() {
            const btn = document.getElementById('runDayPredictionBtn');
            const statusDiv = document.getElementById('fullDayStatus');
            const resultDiv = document.getElementById('fullDayResult');
            const textarea = document.getElementById('fullDayInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Running prediction...';
            resultDiv.innerHTML = '';
            
            try {
                const requestData = JSON.parse(textarea.value);
                
                const response = await fetch('api/predictions/heating_demand_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Prediction completed successfully';
                    
                    // Display result as chart and table
                    const predictions = data.predictions;
                    const maxVal = Math.max(...predictions, 0.1);
                    const timeslots = data.timeslots || requestData.timeslots || [];
                    
                    // Create simple bar chart
                    let chartHtml = '<div class="chart-container"><h4 style="margin-top:0">Hourly Heating Demand</h4>';
                    chartHtml += '<div class="chart-wrapper">';
                    predictions.forEach((pred, idx) => {
                        const height = (pred / maxVal) * 100;
                        const width = Math.max(100 / predictions.length - 1, 5);
                        chartHtml += `<div class="bar" style="height: ${height}%; width: ${width}%" title="${timeslots[idx] || 'Hour ' + idx}: ${pred.toFixed(3)} kWh"></div>`;
                    });
                    chartHtml += '</div>';
                    chartHtml += '<div class="chart-labels">';
                    chartHtml += `<span>00:00</span><span>06:00</span><span>12:00</span><span>18:00</span><span>24:00</span>`;
                    chartHtml += '</div></div>';
                    
                    // Create table
                    chartHtml += '<table class="results-table"><thead><tr><th>Time Slot</th><th>Predicted kWh</th></tr></thead><tbody>';
                    predictions.forEach((pred, idx) => {
                        const slot = timeslots[idx] || `Slot ${idx + 1}`;
                        chartHtml += `<tr><td>${slot}</td><td>${pred.toFixed(4)}</td></tr>`;
                    });
                    chartHtml += '</tbody></table>';
                    chartHtml += `<div class="total-kwh">Total Daily Consumption: ${data.total_kwh.toFixed(4)} kWh</div>`;
                    
                    resultDiv.innerHTML = chartHtml;
                } else {
                    statusDiv.className = 'status-message error';
                    let message = '‚úó ' + data.message;
                    if (data.required_features) {
                        message += '\n\nRequired features: ' + data.required_features.join(', ');
                    }
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadSensorInfo() {
            const btn = document.getElementById('loadSensorsBtn');
            const statusDiv = document.getElementById('sensorInfoStatus');
            const tableDiv = document.getElementById('sensorInfoTable');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading sensor information...';
            tableDiv.innerHTML = '';
            
            try {
                const response = await fetch('api/sensors/info');
                const data = await response.json();
                
                if (response.ok && data.sensors && data.sensors.length > 0) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Found ${data.count} sensors`;
                    
                    let html = '<table class="sensor-table"><thead><tr>';
                    html += '<th>Entity ID</th><th>First Timestamp</th><th>Last Timestamp</th><th>Sample Count</th>';
                    html += '</tr></thead><tbody>';
                    
                    data.sensors.forEach(sensor => {
                        html += `<tr>`;
                        html += `<td>${sensor.entity_id}</td>`;
                        html += `<td>${sensor.first_timestamp || 'N/A'}</td>`;
                        html += `<td>${sensor.last_timestamp || 'N/A'}</td>`;
                        html += `<td>${sensor.sample_count.toLocaleString()}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += '</tbody></table>';
                    tableDiv.innerHTML = html;
                } else if (response.ok) {
                    statusDiv.className = 'status-message info';
                    statusDiv.textContent = '‚ÑπÔ∏è No sensors found in database';
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadScenarioExample() {
            const btn = document.getElementById('loadScenarioExampleBtn');
            const statusDiv = document.getElementById('scenarioStatus');
            const textarea = document.getElementById('scenarioInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading example...';
            
            try {
                const response = await fetch('api/examples/scenario');
                const data = await response.json();
                
                if (response.ok) {
                    textarea.value = JSON.stringify(data.example, null, 2);
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.description;
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function runScenarioPrediction() {
            const btn = document.getElementById('runScenarioPredictionBtn');
            const statusDiv = document.getElementById('scenarioStatus');
            const resultDiv = document.getElementById('scenarioResult');
            const textarea = document.getElementById('scenarioInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Running prediction...';
            resultDiv.innerHTML = '';
            
            try {
                const requestData = JSON.parse(textarea.value);
                
                const response = await fetch('api/predictions/scenario', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Prediction completed successfully - ' + data.slots_count + ' timeslots processed';
                    
                    const predictions = data.predictions;
                    const predValues = predictions.map(p => p.predicted_kwh);
                    const maxVal = Math.max(...predValues, 0.1);
                    
                    // Create simple bar chart
                    let chartHtml = '<div class="chart-container"><h4 style="margin-top:0">Hourly Heating Demand</h4>';
                    chartHtml += '<div class="chart-wrapper">';
                    predictions.forEach((pred, idx) => {
                        const height = (pred.predicted_kwh / maxVal) * 100;
                        const width = Math.max(100 / predictions.length - 1, 5);
                        chartHtml += `<div class="bar" style="height: ${height}%; width: ${width}%" title="${pred.timestamp}: ${pred.predicted_kwh.toFixed(3)} kWh"></div>`;
                    });
                    chartHtml += '</div>';
                    chartHtml += '<div class="chart-labels">';
                    if (predictions.length >= 4) {
                        const step = Math.floor(predictions.length / 4);
                        chartHtml += `<span>${predictions[0].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step*2].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step*3].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[predictions.length-1].timestamp.split('T')[1]}</span>`;
                    }
                    chartHtml += '</div></div>';
                    
                    // Create table
                    chartHtml += '<table class="results-table"><thead><tr><th>Timestamp</th><th>Predicted kWh</th></tr></thead><tbody>';
                    predictions.forEach(pred => {
                        chartHtml += `<tr><td>${pred.timestamp}</td><td>${pred.predicted_kwh.toFixed(4)}</td></tr>`;
                    });
                    chartHtml += '</tbody></table>';
                    chartHtml += `<div class="total-kwh">Total Consumption: ${data.total_kwh.toFixed(4)} kWh</div>`;
                    
                    resultDiv.innerHTML = chartHtml;
                } else {
                    statusDiv.className = 'status-message error';
                    let message = '‚úó ' + data.message;
                    if (data.errors && data.errors.length > 0) {
                        message += '\n\nErrors:\n' + data.errors.join('\n');
                    }
                    if (data.required_fields) {
                        message += '\n\nRequired fields: ' + data.required_fields.join(', ');
                    }
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }
    </script>
</body>
</html>
