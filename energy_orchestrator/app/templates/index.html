<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Energy Orchestrator</title>
    <style>
        :root {
            /* Dark mode (default) */
            --bg-primary: #020617;
            --bg-secondary: #111827;
            --bg-tertiary: #1f2937;
            --text-primary: #e5e7eb;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border-color: #374151;
            --accent-blue: #3b82f6;
            --accent-blue-hover: #2563eb;
            --accent-green: #22c55e;
            --accent-green-dark: #166534;
            --accent-orange: #f59e0b;
            --accent-orange-dark: #78350f;
            --success-bg: #166534;
            --success-text: #86efac;
            --error-bg: #991b1b;
            --error-text: #fca5a5;
            --info-bg: #1e3a8a;
            --info-text: #93c5fd;
        }
        
        [data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #94a3b8;
            --border-color: #cbd5e1;
            --accent-blue: #2563eb;
            --accent-blue-hover: #1d4ed8;
            --accent-green: #16a34a;
            --accent-green-dark: #166534;
            --accent-orange: #d97706;
            --accent-orange-dark: #92400e;
            --success-bg: #dcfce7;
            --success-text: #166534;
            --error-bg: #fee2e2;
            --error-text: #991b1b;
            --info-bg: #dbeafe;
            --info-text: #1e40af;
        }
        
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 1.5rem;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background 0.3s, color 0.3s;
        }
        h1 { margin-top: 0; }
        h3 { margin-bottom: 0.5rem; }
        
        /* Theme toggle */
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 900px;
            margin-bottom: 1rem;
        }
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: background 0.2s;
        }
        .theme-toggle:hover {
            background: var(--bg-tertiary);
        }
        .theme-icon {
            font-size: 1.2rem;
        }
        
        /* Tabs */
        .tabs-container {
            max-width: 900px;
            margin-bottom: 1rem;
        }
        .tabs-nav {
            display: flex;
            gap: 0.25rem;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 1rem;
        }
        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            color: var(--text-secondary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab-btn:hover {
            color: var(--text-primary);
            background: var(--bg-secondary);
        }
        .tab-btn.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
            font-weight: 600;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        .card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            max-width: 900px;
            margin-bottom: 1rem;
        }
        .action-btn {
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 0.5rem;
            margin-right: 0.5rem;
            transition: background 0.2s;
        }
        .action-btn:hover {
            background: var(--accent-blue-hover);
        }
        .action-btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }
        .action-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .action-btn.secondary:hover {
            background: var(--border-color);
        }
        .action-btn.success {
            background: #059669;
        }
        .action-btn.success:hover {
            background: #047857;
        }
        .action-btn.warning {
            background: #d97706;
        }
        .action-btn.warning:hover {
            background: #b45309;
        }
        .action-btn.small {
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
            margin: 0.2rem;
        }
        .status-message {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border-radius: 4px;
            display: none;
            font-size: 0.9rem;
            white-space: pre-wrap;
        }
        .status-message.success {
            background: var(--success-bg);
            color: var(--success-text);
            display: block;
        }
        .status-message.error {
            background: var(--error-bg);
            color: var(--error-text);
            display: block;
        }
        .status-message.loading {
            background: var(--info-bg);
            color: var(--info-text);
            display: block;
        }
        .status-message.info {
            background: var(--info-bg);
            color: var(--info-text);
            display: block;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .stat-item {
            background: var(--bg-tertiary);
            padding: 0.5rem;
            border-radius: 4px;
        }
        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
        }
        hr {
            border-color: var(--border-color);
            margin: 1.5rem 0;
        }
        textarea {
            width: 100%;
            min-height: 150px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 0.85rem;
            padding: 0.75rem;
            resize: vertical;
            box-sizing: border-box;
        }
        textarea:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        .results-table th, .results-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        .results-table th {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-weight: 600;
        }
        .results-table tr:hover {
            background: var(--bg-tertiary);
        }
        .results-table tbody tr {
            cursor: pointer;
        }
        .feature-details-row {
            background: var(--bg-secondary) !important;
        }
        .feature-details-row td {
            padding: 1rem !important;
        }
        .feature-details-content {
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 3px solid var(--accent-blue);
        }
        .feature-tag {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            margin: 0.2rem;
            background: var(--accent-blue);
            color: white;
            border-radius: 4px;
            font-size: 0.8rem;
        }
        .chart-container {
            margin-top: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
            min-height: 200px;
        }
        .bar {
            display: inline-block;
            background: var(--accent-blue);
            margin-right: 2px;
            vertical-align: bottom;
            border-radius: 2px 2px 0 0;
        }
        .chart-wrapper {
            display: flex;
            align-items: flex-end;
            height: 150px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        .chart-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .sensor-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        .sensor-table th, .sensor-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        .sensor-table th {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-weight: 600;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        .data-table th, .data-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        .data-table th {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-weight: 600;
        }
        .data-table tr:hover {
            background: var(--bg-tertiary);
        }
        .data-table input[type="text"], .data-table input[type="number"] {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 0.4rem;
            font-size: 0.85rem;
        }
        .total-kwh {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-green);
            margin-top: 0.5rem;
        }
        .example-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
        .feature-category {
            margin-bottom: 1.5rem;
        }
        .feature-category-title {
            font-size: 1rem;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid var(--border-color);
        }
        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 0.5rem;
        }
        .feature-item {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 0.75rem;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }
        .feature-item.core {
            border-left: 3px solid var(--accent-green);
        }
        .feature-item.experimental {
            border-left: 3px solid var(--accent-orange);
        }
        .feature-item.experimental.disabled {
            opacity: 0.6;
        }
        .feature-toggle {
            flex-shrink: 0;
            margin-top: 2px;
        }
        .feature-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .feature-toggle input[type="checkbox"]:disabled {
            cursor: not-allowed;
        }
        .feature-info {
            flex: 1;
            min-width: 0;
        }
        .feature-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        .feature-badge {
            display: inline-block;
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
            font-weight: 500;
        }
        .feature-badge.core {
            background: var(--accent-green-dark);
            color: #86efac;
        }
        .feature-badge.experimental {
            background: var(--accent-orange-dark);
            color: #fcd34d;
        }
        .feature-description {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
        .feature-meta {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }
        .timezone-config {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        .timezone-config label {
            font-weight: 500;
        }
        .timezone-config select {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        .feature-stats {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        .feature-stat {
            text-align: center;
        }
        .feature-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-blue);
        }
        .feature-stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        /* Training data table */
        .training-data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.85rem;
        }
        .training-data-table th, .training-data-table td {
            padding: 0.5rem;
            text-align: left;
            border: 1px solid var(--border-color);
        }
        .training-data-table th {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-weight: 600;
        }
        .training-data-table td {
            background: var(--bg-secondary);
        }
    </style>
</head>
<body>
    <div class="header-container">
        <h1>‚ö° Energy Orchestrator</h1>
        <button class="theme-toggle" onclick="toggleTheme()">
            <span class="theme-icon" id="themeIcon">üåô</span>
            <span id="themeText">Dark</span>
        </button>
    </div>
    
    <div class="tabs-container">
        <div class="tabs-nav">
            <button class="tab-btn active" onclick="switchTab('configuration')">‚öôÔ∏è Configuration</button>
            <button class="tab-btn" onclick="switchTab('sensorConfig')">üì° Sensor Configuration</button>
            <button class="tab-btn" onclick="switchTab('training')">ü§ñ Model Training</button>
            <button class="tab-btn" onclick="switchTab('optimizer')">üîç Optimizer</button>
            <button class="tab-btn" onclick="switchTab('sensors')">üìä Sensor Information</button>
        </div>
    </div>

    <!-- Configuration Tab -->
    <div id="tab-configuration" class="tab-content active">
        <div class="card">
            <h3>üîÑ Data Resampling</h3>
            <p>Resample raw sensor data into time slots and save to resampled_samples table.</p>
            
            <div class="timezone-config" style="margin-bottom: 1rem;">
                <label for="sampleRateSelect">üìä Sample Rate (minutes):</label>
                <select id="sampleRateSelect" onchange="updateSampleRate()" style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem 1rem; font-size: 0.9rem;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5" selected>5</option>
                    <option value="6">6</option>
                    <option value="10">10</option>
                    <option value="12">12</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                    <option value="30">30</option>
                    <option value="60">60</option>
                </select>
                <span style="color: var(--text-secondary); font-size: 0.85rem;">Current: <span id="sampleRateText">5</span> minutes</span>
            </div>
            
            <div style="margin-bottom: 0.5rem;">
                <label for="flushCheckbox" style="cursor: pointer;">
                    <input type="checkbox" id="flushCheckbox" style="margin-right: 0.5rem;">
                    Flush existing data (required when sample rate changes)
                </label>
            </div>
            <button class="action-btn" id="resampleBtn" onclick="triggerResample()">Resample Data</button>
            <div id="resampleStatus" class="status-message"></div>
        </div>

        <div class="card">
            <h3>üì° Sync Configuration</h3>
            <p>Configure how sensor data is synchronized from Home Assistant history.</p>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                <div class="stat-item">
                    <div class="stat-label">Backfill Days</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="number" id="backfillDaysInput" min="1" max="365" value="14" 
                            style="width: 80px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem; font-size: 0.9rem;">
                        <span style="color: var(--text-secondary); font-size: 0.8rem;">days (when no samples exist)</span>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Sync Window Size</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="number" id="syncWindowDaysInput" min="1" max="30" value="1" 
                            style="width: 80px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem; font-size: 0.9rem;">
                        <span style="color: var(--text-secondary); font-size: 0.8rem;">days per sync request</span>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Sensor Sync Interval</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="number" id="sensorSyncIntervalInput" min="1" max="3600" value="1" 
                            style="width: 80px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem; font-size: 0.9rem;">
                        <span style="color: var(--text-secondary); font-size: 0.8rem;">seconds between sensors</span>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Loop Interval</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="number" id="sensorLoopIntervalInput" min="1" max="3600" value="1" 
                            style="width: 80px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem; font-size: 0.9rem;">
                        <span style="color: var(--text-secondary); font-size: 0.8rem;">seconds between sync loops</span>
                    </div>
                </div>
            </div>
            
            <button class="action-btn" id="saveSyncConfigBtn" onclick="saveSyncConfig()">Save Configuration</button>
            <button class="action-btn secondary" id="loadSyncConfigBtn" onclick="loadSyncConfig()">Reload</button>
            <div id="syncConfigStatus" class="status-message"></div>
        </div>

        <div class="card">
            <h3>‚öôÔ∏è Feature Configuration</h3>
            <p class="example-description">
                Configure which features are used for model training and prediction. Time/Date and kWh features are always shown. 
                Physical sensor cards with their aggregation features can be shown/hidden using the button below.
                Core features are labeled 'CORE' but can be disabled. Experimental features are labeled 'EXPERIMENTAL' and disabled by default.
            </p>
            <p class="example-description" style="margin-top: 0.5rem;">
                <strong>üìù Note:</strong> Configuration loads automatically. To manage raw sensors and configure which statistics to calculate, 
                use the <strong>üì° Sensor Configuration</strong> tab.
            </p>
            
            <div id="featureConfigStatus" class="status-message"></div>
            <div id="featureConfigContent"></div>
            
            <button class="action-btn secondary" id="showSensorCardsBtn" onclick="toggleSensorCards()" style="margin-top: 1rem; margin-bottom: 1rem;">
                üìä Show Sensor Cards
            </button>
            
            <div id="sensorCardsContainer" style="display: none;"></div>
        </div>

        <div class="card">
            <h3>üîÄ Two-Step Prediction</h3>
            <span class="feature-badge experimental" style="margin-left: 0.5rem; vertical-align: middle;">EXPERIMENTAL</span>
            <p class="example-description" style="margin-top: 0.5rem;">
                An advanced prediction approach that improves accuracy by first classifying hours as active (heating on) or inactive (heating off), 
                then predicting kWh consumption only for active hours. Inactive hours are predicted as 0 kWh.
            </p>
            
            <div class="feature-item experimental" style="margin: 1rem 0; border-left: 3px solid var(--accent-orange);">
                <div class="feature-toggle">
                    <input type="checkbox" id="twoStepPredictionToggle" onchange="toggleTwoStepPrediction(this.checked)" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="feature-info">
                    <div class="feature-name">Enable Two-Step Prediction</div>
                    <div class="feature-description">When enabled, model training will create both a classifier and a regressor. The classifier predicts active/inactive hours, and the regressor predicts kWh for active hours only.</div>
                </div>
            </div>
            
            <div id="twoStepModelInfo" style="margin-top: 1rem;"></div>
            <button class="action-btn secondary" id="loadTwoStepStatusBtn" onclick="loadTwoStepModelStatus()">Check Two-Step Model Status</button>
            <div id="twoStepConfigStatus" class="status-message"></div>
        </div>

        <div class="card">
            <h3>üå§Ô∏è Weather API Settings</h3>
            <p class="example-description">Configure weather forecast API from weerlive.nl to load real weather data for predictions.</p>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                <div class="stat-item">
                    <div class="stat-label">API Key</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="password" id="weatherApiKeyInput" placeholder="Enter API key"
                            style="flex: 1; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem; font-size: 0.9rem;">
                        <button onclick="toggleApiKeyVisibility()" class="action-btn secondary" style="padding: 0.5rem 0.75rem; margin: 0;">üëÅÔ∏è</button>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Location</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="text" id="weatherLocationInput" placeholder="e.g., Amsterdam"
                            style="flex: 1; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem; font-size: 0.9rem;">
                    </div>
                </div>
            </div>
            
            <p class="example-description">Get your free API key at: <a href="https://weerlive.nl/delen.php" target="_blank" style="color: var(--accent-blue);">weerlive.nl/delen.php</a></p>
            
            <button class="action-btn" id="saveWeatherConfigBtn" onclick="saveWeatherConfig()">Save & Validate</button>
            <button class="action-btn secondary" id="testWeatherBtn" onclick="testWeatherApi()">Test Connection</button>
            <button class="action-btn secondary" id="loadWeatherConfigBtn" onclick="loadWeatherConfig()">Reload</button>
            <div id="weatherConfigStatus" class="status-message"></div>
        </div>
    </div>

    <!-- Sensor Configuration Tab -->
    <div id="tab-sensorConfig" class="tab-content">
        <div class="card">
            <h3>üìä Raw Sensors</h3>
            <p>Configure raw sensors that are directly read from Home Assistant. Add unit information and view current values.</p>
            <button class="action-btn secondary" id="loadRawSensorsBtn" onclick="loadRawSensors()">Load Sensors</button>
            <div id="rawSensorsStatus" class="status-message"></div>
            <div id="rawSensorsTable"></div>
        </div>

        <div class="card">
            <h3>üîó Virtual Sensors</h3>
            <p>Create virtual (derived) sensors based on two existing sensors. Example: delta = target_temp - indoor_temp</p>
            <div style="margin-bottom: 20px;">
                <button class="action-btn" id="addVirtualSensorBtn" onclick="showAddVirtualSensorDialog()">+ Add Virtual Sensor</button>
                <button class="action-btn secondary" id="loadVirtualSensorsBtn" onclick="loadVirtualSensors()">Reload List</button>
            </div>
            <div id="virtualSensorsStatus" class="status-message"></div>
            <div id="virtualSensorsTable"></div>
        </div>

        <div class="card">
            <h3>üìà Feature Stats Configuration</h3>
            <p>Configure which time-based statistics (avg_1h, avg_6h, avg_24h, avg_7d) should be generated for each sensor during resampling.</p>
            <button class="action-btn secondary" id="loadFeatureStatsBtn" onclick="loadFeatureStatsConfig()">Load Configuration</button>
            <div id="featureStatsStatus" class="status-message"></div>
            <div id="featureStatsTable"></div>
        </div>
    </div>

    <!-- Model Training Tab -->
    <div id="tab-training" class="tab-content">
        <div class="card">
            <h3>ü§ñ Single-Step Model Training</h3>
            <p>Train the standard heating demand prediction model using resampled data. This model directly predicts kWh for each hour.</p>
            <button class="action-btn success" id="trainBtn" onclick="trainModel()">Train Model</button>
            <button class="action-btn secondary" id="statusBtn" onclick="getModelStatus()">Check Status</button>
            <div id="modelStatus" class="status-message"></div>
            <div id="trainingDataTable"></div>
        </div>

        <div class="card">
            <h3>üîÄ Two-Step Model Training</h3>
            <span class="feature-badge experimental" style="margin-left: 0.5rem; vertical-align: middle;">EXPERIMENTAL</span>
            <p class="example-description" style="margin-top: 0.5rem;">
                Train the two-step heating demand model: a classifier + regressor approach. 
                The classifier predicts active/inactive hours, the regressor predicts kWh for active hours only.
            </p>
            
            <div class="stats-grid" id="twoStepTrainingStats" style="display: none;">
                <div class="stat-item">
                    <div class="stat-label">Activity Threshold</div>
                    <div class="stat-value" id="twoStepThreshold">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Active Samples</div>
                    <div class="stat-value" id="twoStepActiveSamples">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Inactive Samples</div>
                    <div class="stat-value" id="twoStepInactiveSamples">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Classifier Accuracy</div>
                    <div class="stat-value" id="twoStepClassifierAccuracy">-</div>
                </div>
            </div>
            
            <button class="action-btn warning" id="trainTwoStepBtn" onclick="trainTwoStepModel()">Train Two-Step Model</button>
            <button class="action-btn secondary" id="twoStepStatusBtn" onclick="getTwoStepModelStatus()">Check Status</button>
            <div id="twoStepModelStatus" class="status-message"></div>
            <div id="twoStepTrainingDataTable"></div>
        </div>

        <div class="card">
            <h3>üå°Ô∏è Scenario-Based Prediction (Simplified)</h3>
            <p class="example-description">Predict heating demand using simple, human-readable inputs. No need to calculate model features - just provide weather forecast and setpoint schedule.</p>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 0.5rem;">
                <button class="action-btn secondary" id="loadScenarioExampleBtn" onclick="loadScenarioExample()">Load Example (24h)</button>
                <button class="action-btn warning" id="loadWeatherForecastBtn" onclick="loadWeatherForecast()">üå§Ô∏è Load Weather (24h)</button>
                <span style="color: var(--text-secondary);">or load from historical data:</span>
                <select id="historicalDaySelect" onchange="loadHistoricalDay()" style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); padding: 0.5rem; cursor: pointer;">
                    <option value="">Select historical day...</option>
                </select>
                <button class="action-btn secondary" id="refreshDaysBtn" onclick="loadAvailableDays()" style="padding: 0.5rem 1rem;">‚Üª</button>
            </div>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 0.5rem;">
                <label style="color: var(--text-secondary);">Target Temperature:</label>
                <input type="number" id="targetTempInput" value="20.0" step="0.5" min="15" max="25"
                    style="width: 80px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem; font-size: 0.9rem;">
                <span style="color: var(--text-secondary);">¬∞C</span>
            </div>
            <button class="action-btn success" id="runScenarioPredictionBtn" onclick="runScenarioPrediction()">Run Prediction</button>
            <button class="action-btn" id="storePredictionBtn" onclick="storePrediction()" style="display: none;">üíæ Store Prediction</button>
            <p class="example-description" style="margin-top: 0.5rem;">Required per timeslot: timestamp (future), outdoor_temperature, wind_speed, humidity, pressure, target_temperature. Optional: indoor_temperature</p>
            <textarea id="scenarioInput" placeholder='{"timeslots": [{"timestamp": "2024-01-15T14:00:00", "outdoor_temperature": 5.0, "wind_speed": 3.0, "humidity": 75.0, "pressure": 1013.0, "target_temperature": 20.0}, ...]}'></textarea>
            <div id="scenarioStatus" class="status-message"></div>
            <div id="scenarioResult"></div>
        </div>

        <div class="card">
            <h3>üìä Stored Predictions</h3>
            <p class="example-description">View and compare stored predictions with actual sensor data.</p>
            <button class="action-btn secondary" id="loadStoredPredictionsBtn" onclick="loadStoredPredictions()">Load Stored Predictions</button>
            <div id="storedPredictionsStatus" class="status-message"></div>
            <div id="storedPredictionsList"></div>
            <div id="comparisonResult"></div>
        </div>

    </div>

    <!-- Optimizer Tab -->
    <div id="tab-optimizer" class="tab-content">
        <div class="card">
            <h3>üîç Settings Optimizer</h3>
            <p class="example-description">
                Automatically find the best model configuration by testing different feature combinations. 
                The optimizer cycles through experimental features and trains both single-step and two-step models 
                to find the configuration with the lowest validation MAPE (%).
            </p>
            <p class="example-description" style="margin-top: 0.5rem;">
                <strong>‚ö†Ô∏è Note:</strong> This process may take several minutes as it trains multiple models.
                Your current settings will be saved before starting and restored after completion.
            </p>
            
            <!-- Optimizer Configuration -->
            <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                <h4 style="margin-top: 0; margin-bottom: 0.75rem;">‚öôÔ∏è Optimizer Settings</h4>
                <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                    <label for="maxWorkersInput" style="display: flex; align-items: center; gap: 0.5rem;">
                        <span style="color: var(--text-secondary);">Max Workers:</span>
                        <input 
                            type="number" 
                            id="maxWorkersInput" 
                            min="0" 
                            max="20" 
                            placeholder="0 (auto)" 
                            style="width: 80px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); padding: 0.35rem 0.5rem;"
                            onchange="saveOptimizerConfig()"
                        />
                        <span style="color: var(--text-secondary); font-size: 0.85rem;">(0 = auto-calculate)</span>
                    </label>
                    <div id="optimizerConfigStatus" style="color: var(--text-secondary); font-size: 0.85rem;"></div>
                </div>
                <p style="margin: 0.5rem 0 0 0; color: var(--text-secondary); font-size: 0.85rem;">
                    <strong>Tip:</strong> Leave at 0 to auto-calculate based on available CPU and memory. 
                    Manual limit useful to prevent OOM kills on systems with limited memory.
                </p>
            </div>
            
            <!-- Run Optimizer Controls -->
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem;">
                <button class="action-btn success" id="runOptimizerBtn" onclick="runOptimizer()">üîç Start Optimization</button>
            </div>
            
            <!-- Progress Display (never overwritten by status checks) -->
            <div id="optimizerProgress" style="display: none; margin-bottom: 1rem;">
                <h4 style="margin-bottom: 0.5rem;">‚è≥ Optimization Progress</h4>
                <div id="optimizerProgressContent" class="status-message loading"></div>
                <div id="optimizerLog" style="margin-top: 1rem;">
                    <h4 style="margin-bottom: 0.5rem;">üìã Optimization Log</h4>
                    <div id="optimizerLogContent" style="background: var(--bg-tertiary); border-radius: 8px; padding: 1rem; max-height: 300px; overflow-y: auto; font-family: 'Fira Code', 'Monaco', 'Consolas', monospace; font-size: 0.8rem; white-space: pre-wrap;"></div>
                </div>
            </div>
            
            <!-- Status Check Display (separate from progress) -->
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem;">
                <button class="action-btn secondary" id="optimizerStatusBtn" onclick="checkOptimizerStatus()">üìä Check Status</button>
            </div>
            <div id="optimizerStatusDisplay" class="status-message" style="display: none;"></div>
        </div>

        <!-- Best Result Card (always visible if exists) -->
        <div class="card" id="optimizerBestResultCard" style="display: none;">
            <h3>üèÜ Best Configuration</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Configuration</div>
                    <div class="stat-value" id="optimizerBestConfig" style="font-size: 1rem;">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Model Type</div>
                    <div class="stat-value" id="optimizerBestModel">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Val MAPE</div>
                    <div class="stat-value" id="optimizerBestMape" style="color: var(--accent-green);">-</div>
                </div>
            </div>
            <button class="action-btn" id="applyOptimizerBtn" onclick="applyOptimizerResult()" style="margin-top: 1rem;">‚úì Apply Best Settings</button>
        </div>

        <!-- Results Table (always visible, shows top 30) -->
        <div class="card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <h3 style="margin: 0;">üìä Optimization Results (Top 30)</h3>
                <button class="action-btn secondary" id="refreshResultsBtn" onclick="loadOptimizerResultsTable()" style="padding: 0.5rem 1rem;">üîÑ Refresh Results</button>
            </div>
            <p class="example-description">Click on a row to view features used in training. Results are automatically loaded from the last optimizer run.</p>
            <div id="optimizerResultsTable"></div>
        </div>

        <!-- Re-train with specific configuration -->
        <div class="card">
            <h3>üîÑ Re-train Model with Selected Configuration</h3>
            <p class="example-description">After selecting a configuration from the results table, you can re-train the model with that exact feature set.</p>
            <div style="margin-bottom: 1rem;">
                <label for="selectedResultId" style="color: var(--text-secondary); display: block; margin-bottom: 0.5rem;">Selected Result ID:</label>
                <input type="number" id="selectedResultId" placeholder="Enter result ID" style="width: 150px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.5rem;">
            </div>
            <button class="action-btn success" id="retrainFromResultBtn" onclick="retrainFromResult()">üîÑ Re-train with Selected Configuration</button>
            <div id="retrainStatus" class="status-message"></div>
        </div>
    </div>

    <!-- Sensor Information Tab -->
    <div id="tab-sensors" class="tab-content">
        <div class="card">
            <h3>üìä Sensor Information</h3>
            <p>View first and last timestamp for each sensor in the database.</p>
            <button class="action-btn secondary" id="loadSensorsBtn" onclick="loadSensorInfo()">Load Sensor Info</button>
            <div id="sensorInfoStatus" class="status-message"></div>
            <div id="sensorInfoTable"></div>
        </div>
    </div>

    <script>
        // Store historical data when loaded for comparison in table
        let currentHistoricalData = null;
        
        // Theme management
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeUI(newTheme);
        }
        
        function updateThemeUI(theme) {
            const icon = document.getElementById('themeIcon');
            const text = document.getElementById('themeText');
            if (theme === 'light') {
                icon.textContent = '‚òÄÔ∏è';
                text.textContent = 'Light';
            } else {
                icon.textContent = 'üåô';
                text.textContent = 'Dark';
            }
        }
        
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeUI(savedTheme);
        }
        
        // Tab management
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById('tab-' + tabName).classList.add('active');
            
            // Activate clicked tab button
            event.target.classList.add('active');
            
            // Auto-load data for Configuration tab
            if (tabName === 'configuration') {
                loadFeatureConfigAuto();
            }
            
            // Auto-load latest optimizer results for Optimizer tab
            if (tabName === 'optimizer') {
                loadLatestOptimizerResults();
            }
            
            // Auto-load latest optimizer results for Training tab
            if (tabName === 'training') {
                // No longer load optimizer results here since it's moved to optimizer tab
            }
        }
        
        // Load available days and sample rate on page load
        document.addEventListener('DOMContentLoaded', function() {
            initTheme();
            loadAvailableDays();
            loadSampleRate();
            loadSyncConfig();
            loadTwoStepPredictionStatus();
            loadWeatherConfig();
            loadOptimizerConfig();
            // Auto-load features for Configuration tab (default active tab)
            loadFeatureConfigAuto();
        });
        
        async function loadSampleRate() {
            try {
                const response = await fetch('api/sample_rate');
                const data = await response.json();
                
                if (response.ok) {
                    document.getElementById('sampleRateText').textContent = data.sample_rate_minutes;
                    document.getElementById('sampleRateSelect').value = data.sample_rate_minutes;
                }
            } catch (error) {
                console.error('Error loading sample rate:', error);
            }
        }
        
        async function updateSampleRate() {
            const select = document.getElementById('sampleRateSelect');
            const statusDiv = document.getElementById('resampleStatus');
            const newRate = parseInt(select.value);
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Updating sample rate...';
            
            try {
                const response = await fetch('api/sample_rate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sample_rate_minutes: newRate })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    document.getElementById('sampleRateText').textContent = data.sample_rate_minutes;
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message + '\n\n' + data.note;
                    
                    // Automatically check the flush checkbox when sample rate changes
                    document.getElementById('flushCheckbox').checked = true;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    // Reload to restore the previous value
                    loadSampleRate();
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                loadSampleRate();
            }
        }
        
        async function loadAvailableDays() {
            const select = document.getElementById('historicalDaySelect');
            
            try {
                const response = await fetch('api/examples/available_days');
                const data = await response.json();
                
                // Clear existing options except first
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                if (response.ok && data.days && data.days.length > 0) {
                    data.days.forEach(day => {
                        const option = document.createElement('option');
                        option.value = day;
                        option.textContent = day;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading available days:', error);
            }
        }
        
        async function loadSyncConfig() {
            try {
                const response = await fetch('api/sync_config');
                const data = await response.json();
                
                if (response.ok) {
                    document.getElementById('backfillDaysInput').value = data.config.backfill_days;
                    document.getElementById('syncWindowDaysInput').value = data.config.sync_window_days;
                    document.getElementById('sensorSyncIntervalInput').value = data.config.sensor_sync_interval;
                    document.getElementById('sensorLoopIntervalInput').value = data.config.sensor_loop_interval;
                }
            } catch (error) {
                console.error('Error loading sync config:', error);
            }
        }
        
        async function saveSyncConfig() {
            const statusDiv = document.getElementById('syncConfigStatus');
            const btn = document.getElementById('saveSyncConfigBtn');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Saving configuration...';
            
            try {
                const backfillDays = parseInt(document.getElementById('backfillDaysInput').value);
                const syncWindowDays = parseInt(document.getElementById('syncWindowDaysInput').value);
                const sensorSyncInterval = parseInt(document.getElementById('sensorSyncIntervalInput').value);
                const sensorLoopInterval = parseInt(document.getElementById('sensorLoopIntervalInput').value);
                
                const response = await fetch('api/sync_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        backfill_days: backfillDays,
                        sync_window_days: syncWindowDays,
                        sensor_sync_interval: sensorSyncInterval,
                        sensor_loop_interval: sensorLoopInterval
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    // Update input values with saved values
                    document.getElementById('backfillDaysInput').value = data.config.backfill_days;
                    document.getElementById('syncWindowDaysInput').value = data.config.sync_window_days;
                    document.getElementById('sensorSyncIntervalInput').value = data.config.sensor_sync_interval;
                    document.getElementById('sensorLoopIntervalInput').value = data.config.sensor_loop_interval;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }
        
        async function loadTwoStepPredictionStatus() {
            try {
                const response = await fetch('api/features/two_step_prediction');
                const data = await response.json();
                
                if (response.ok) {
                    document.getElementById('twoStepPredictionToggle').checked = data.two_step_prediction_enabled;
                    
                    // Also update the model info section
                    const infoDiv = document.getElementById('twoStepModelInfo');
                    if (data.two_step_model_available) {
                        infoDiv.innerHTML = `
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <div class="stat-label">Activity Threshold</div>
                                    <div class="stat-value">${data.activity_threshold_kwh !== null ? data.activity_threshold_kwh.toFixed(4) + ' kWh' : '-'}</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-label">Model Status</div>
                                    <div class="stat-value" style="color: var(--accent-green);">Available</div>
                                </div>
                            </div>
                        `;
                    } else {
                        infoDiv.innerHTML = `
                            <div class="stat-item" style="background: var(--bg-tertiary); padding: 0.75rem; border-radius: 8px;">
                                <div style="color: var(--text-secondary);">Two-step model not trained yet. Go to Model Training tab to train it.</div>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error loading two-step prediction status:', error);
            }
        }
        
        async function toggleTwoStepPrediction(enabled) {
            const statusDiv = document.getElementById('twoStepConfigStatus');
            
            try {
                const response = await fetch('api/features/two_step_prediction', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: enabled })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    // Reload to restore checkbox state
                    loadTwoStepPredictionStatus();
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                loadTwoStepPredictionStatus();
            }
        }
        
        async function loadTwoStepModelStatus() {
            const statusDiv = document.getElementById('twoStepConfigStatus');
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading two-step model status...';
            
            try {
                const response = await fetch('api/model/two_step_status');
                const data = await response.json();
                
                if (data.status === 'available') {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Two-step model is available\n` +
                        `Activity threshold: ${data.activity_threshold_kwh.toFixed(4)} kWh\n` +
                        `Training timestamp: ${data.training_timestamp || 'Unknown'}`;
                } else {
                    statusDiv.className = 'status-message info';
                    statusDiv.textContent = '‚ÑπÔ∏è ' + data.message;
                }
                
                // Also refresh the main status
                loadTwoStepPredictionStatus();
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }
        
        async function trainTwoStepModel() {
            const btn = document.getElementById('trainTwoStepBtn');
            const statusDiv = document.getElementById('twoStepModelStatus');
            const tableDiv = document.getElementById('twoStepTrainingDataTable');
            const statsDiv = document.getElementById('twoStepTrainingStats');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Training two-step model... This may take a while.';
            tableDiv.innerHTML = '';
            statsDiv.style.display = 'none';
            
            try {
                const response = await fetch('api/train/two_step_heating_demand', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const threshold = data.threshold || {};
                    const classifierMetrics = data.classifier_metrics || {};
                    const regressorMetrics = data.regressor_metrics || {};
                    const trainingData = data.training_data || {};
                    
                    // Update stats display
                    const thresholdValue = threshold.computed_threshold_kwh;
                    document.getElementById('twoStepThreshold').textContent = thresholdValue != null ? thresholdValue.toFixed(4) + ' kWh' : 'N/A';
                    document.getElementById('twoStepActiveSamples').textContent = threshold.active_samples != null ? threshold.active_samples : '-';
                    document.getElementById('twoStepInactiveSamples').textContent = threshold.inactive_samples != null ? threshold.inactive_samples : '-';
                    document.getElementById('twoStepClassifierAccuracy').textContent = classifierMetrics.accuracy != null ? (classifierMetrics.accuracy * 100).toFixed(1) + '%' : '-';
                    statsDiv.style.display = 'grid';
                    
                    // Extract step-specific info from API response
                    const step1 = data.step1_classifier || {};
                    const step2 = data.step2_regressor || {};
                    
                    let message = '‚úì ' + data.message + '\n\n';
                    message += '--- Step 1: Classifier (Active/Inactive Hours) ---\n';
                    message += 'Activity threshold: ' + (thresholdValue != null ? thresholdValue.toFixed(4) : 'N/A') + ' kWh\n';
                    message += 'Active samples: ' + (threshold.active_samples != null ? threshold.active_samples : '-') + '\n';
                    message += 'Inactive samples: ' + (threshold.inactive_samples != null ? threshold.inactive_samples : '-') + '\n';
                    message += 'Accuracy: ' + (classifierMetrics.accuracy != null ? (classifierMetrics.accuracy * 100).toFixed(1) + '%' : 'N/A') + '\n';
                    message += 'Precision: ' + (classifierMetrics.precision != null ? (classifierMetrics.precision * 100).toFixed(1) + '%' : 'N/A') + '\n';
                    message += 'Recall: ' + (classifierMetrics.recall != null ? (classifierMetrics.recall * 100).toFixed(1) + '%' : 'N/A') + '\n';
                    message += 'F1 Score: ' + (classifierMetrics.f1 != null ? (classifierMetrics.f1 * 100).toFixed(1) + '%' : 'N/A') + '\n';
                    if (step1.features_used && step1.features_used.length > 0) {
                        message += 'Features (' + step1.features_used.length + '): ' + step1.features_used.join(', ') + '\n';
                    }
                    message += '\n';
                    message += '--- Step 2: Regressor (kWh for Active Hours) ---\n';
                    message += 'Training samples: ' + (regressorMetrics.train_samples != null ? regressorMetrics.train_samples : '-') + '\n';
                    message += 'Validation samples: ' + (regressorMetrics.val_samples != null ? regressorMetrics.val_samples : '-') + '\n';
                    message += 'Train MAE (kWh): ' + (regressorMetrics.train_mae_kwh != null ? regressorMetrics.train_mae_kwh : 'N/A') + '\n';
                    message += 'Val MAE (kWh): ' + (regressorMetrics.val_mae_kwh != null ? regressorMetrics.val_mae_kwh : 'N/A') + '\n';
                    message += 'Val MAPE (%): ' + (regressorMetrics.val_mape_pct != null ? regressorMetrics.val_mape_pct : 'N/A') + '\n';
                    message += 'Val R¬≤: ' + (regressorMetrics.val_r2 || 'N/A') + '\n';
                    if (step2.features_used && step2.features_used.length > 0) {
                        message += 'Features (' + step2.features_used.length + '): ' + step2.features_used.join(', ');
                    }
                    
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                    
                    // Display training data table with all sensor categories
                    if (trainingData && Object.keys(trainingData).length > 0) {
                        const isValidNumber = (val) => val !== null && val !== undefined && !isNaN(val);
                        
                        let tableHtml = '<h4 style="margin-top: 1rem; margin-bottom: 0.5rem;">üìä Training Data Range</h4>';
                        tableHtml += '<table class="training-data-table">';
                        tableHtml += '<thead><tr><th>Sensor</th><th>First Value</th><th>Last Value</th><th>Delta</th></tr></thead>';
                        tableHtml += '<tbody>';
                        
                        const sortedSensors = Object.keys(trainingData).sort();
                        
                        for (const sensor of sortedSensors) {
                            const sensorData = trainingData[sensor];
                            const unit = sensorData.unit || '';
                            
                            tableHtml += '<tr>';
                            tableHtml += '<td><strong>' + sensor + '</strong></td>';
                            tableHtml += '<td>' + (isValidNumber(sensorData.first) ? sensorData.first.toFixed(2) + ' ' + unit : 'N/A') + '</td>';
                            tableHtml += '<td>' + (isValidNumber(sensorData.last) ? sensorData.last.toFixed(2) + ' ' + unit : 'N/A') + '</td>';
                            
                            if (sensor === 'hp_kwh_total' && isValidNumber(sensorData.delta)) {
                                tableHtml += '<td style="color: var(--accent-green); font-weight: bold;">' + sensorData.delta.toFixed(2) + ' ' + unit + '</td>';
                            } else if (isValidNumber(sensorData.first) && isValidNumber(sensorData.last)) {
                                const delta = sensorData.last - sensorData.first;
                                tableHtml += '<td>' + (delta >= 0 ? '+' : '') + delta.toFixed(2) + ' ' + unit + '</td>';
                            } else {
                                tableHtml += '<td>N/A</td>';
                            }
                            tableHtml += '</tr>';
                        }
                        
                        tableHtml += '</tbody></table>';
                        tableDiv.innerHTML = tableHtml;
                    }
                    
                    // Update the config page status
                    loadTwoStepPredictionStatus();
                } else {
                    let message = '‚úó ' + (data.message || 'Training failed');
                    if (data.stats) {
                        message += '\n\nDataset stats:';
                        message += '\nTotal slots: ' + (data.stats.total_slots || 0);
                        message += '\nValid slots: ' + (data.stats.valid_slots || 0);
                    }
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }
        
        async function getTwoStepModelStatus() {
            const btn = document.getElementById('twoStepStatusBtn');
            const statusDiv = document.getElementById('twoStepModelStatus');
            const statsDiv = document.getElementById('twoStepTrainingStats');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Checking two-step model status...';
            
            try {
                const response = await fetch('api/model/two_step_status');
                const data = await response.json();
                
                if (data.status === 'available') {
                    // Update stats display
                    const thresholdKwh = data.activity_threshold_kwh;
                    document.getElementById('twoStepThreshold').textContent = thresholdKwh != null ? thresholdKwh.toFixed(4) + ' kWh' : 'N/A';
                    document.getElementById('twoStepActiveSamples').textContent = '-';
                    document.getElementById('twoStepInactiveSamples').textContent = '-';
                    document.getElementById('twoStepClassifierAccuracy').textContent = '-';
                    statsDiv.style.display = 'grid';
                    
                    let message = '‚úì Two-step model is available\n\n';
                    message += 'Activity threshold: ' + (thresholdKwh != null ? thresholdKwh.toFixed(4) : 'N/A') + ' kWh\n';
                    message += 'Training timestamp: ' + (data.training_timestamp || 'Unknown') + '\n';
                    if (data.features && data.features.length > 0) {
                        message += '\n--- Features (used by both steps) ---\n';
                        message += 'Step 1 (Classifier): ' + data.features.length + ' features\n';
                        message += 'Step 2 (Regressor): ' + data.features.length + ' features\n';
                        message += 'Features: ' + data.features.join(', ');
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                } else {
                    statsDiv.style.display = 'none';
                    statusDiv.className = 'status-message info';
                    statusDiv.textContent = '‚ÑπÔ∏è ' + (data.message || 'No two-step model available');
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }
        
        async function loadHistoricalDay() {
            const select = document.getElementById('historicalDaySelect');
            const selectedDay = select.value;
            
            if (!selectedDay) {
                currentHistoricalData = null;
                return;
            }
            
            const statusDiv = document.getElementById('scenarioStatus');
            const textarea = document.getElementById('scenarioInput');
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading historical data for ' + selectedDay + '...';
            
            try {
                const response = await fetch('api/examples/historical_day/' + selectedDay);
                const data = await response.json();
                
                if (response.ok) {
                    // Store historical data for comparison
                    currentHistoricalData = data.hourly_data;
                    
                    // Load scenario format into textarea
                    textarea.value = JSON.stringify(data.scenario_format, null, 2);
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Loaded historical data for ' + selectedDay + '. Run prediction to compare model output with actual data.';
                    
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    currentHistoricalData = null;
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                currentHistoricalData = null;
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        async function triggerResample() {
            const btn = document.getElementById('resampleBtn');
            const statusDiv = document.getElementById('resampleStatus');
            const flushCheckbox = document.getElementById('flushCheckbox');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Resampling in progress...';
            
            try {
                const requestBody = {};
                if (flushCheckbox.checked) {
                    requestBody.flush = true;
                }
                
                const response = await fetch('resample', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const stats = data.stats || {};
                    let message = '‚úì ' + data.message + '\n\n';
                    if (stats.table_flushed) {
                        message += '‚ö†Ô∏è Existing resampled data was flushed\n';
                    }
                    message += 'Sample rate: ' + (stats.sample_rate_minutes || 5) + ' minutes\n';
                    message += 'Slots processed: ' + (stats.slots_processed || 0) + '\n';
                    message += 'Slots saved: ' + (stats.slots_saved || 0) + '\n';
                    message += 'Slots skipped: ' + (stats.slots_skipped || 0) + '\n';
                    if (stats.categories && stats.categories.length > 0) {
                        message += 'Categories: ' + stats.categories.join(', ') + '\n';
                    }
                    if (stats.start_time) {
                        message += 'Time range: ' + stats.start_time + ' to ' + stats.end_time;
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                    
                    // Uncheck the flush checkbox after successful resample
                    flushCheckbox.checked = false;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function trainModel() {
            const btn = document.getElementById('trainBtn');
            const statusDiv = document.getElementById('modelStatus');
            const tableDiv = document.getElementById('trainingDataTable');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Training model... This may take a while.';
            tableDiv.innerHTML = '';
            
            try {
                const response = await fetch('api/train/heating_demand', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const metrics = data.metrics || {};
                    const stats = data.dataset_stats || {};
                    const trainingData = data.training_data || {};
                    const featureCategories = data.feature_categories || {};
                    
                    let message = '‚úì ' + data.message + '\n\n';
                    
                    // Dataset information (dynamic, not static)
                    message += '--- Training Dataset ---\n';
                    if (stats.data_start_time && stats.data_end_time) {
                        message += 'Data range: ' + stats.data_start_time + ' to ' + stats.data_end_time + '\n';
                    }
                    if (stats.available_history_hours) {
                        const days = (stats.available_history_hours / 24).toFixed(1);
                        message += 'History: ' + stats.available_history_hours + ' hours (~' + days + ' days)\n';
                    }
                    message += 'Training samples: ' + (metrics.train_samples || 0) + '\n';
                    message += 'Validation samples: ' + (metrics.val_samples || 0) + '\n';
                    message += '\n';
                    
                    // Model performance
                    message += '--- Model Performance ---\n';
                    message += 'Train MAE (kWh): ' + (metrics.train_mae_kwh || 'N/A') + '\n';
                    message += 'Val MAE (kWh): ' + (metrics.val_mae_kwh || 'N/A') + '\n';
                    message += 'Val MAPE (%): ' + (metrics.val_mape_pct || 'N/A') + '\n';
                    message += 'Val R¬≤: ' + (metrics.val_r2 || 'N/A') + '\n';
                    message += '\n';
                    
                    // Features used (dynamic - shows exactly what was used for training)
                    message += '--- Features Used for Training ---\n';
                    const featureCount = metrics.features ? metrics.features.length : 0;
                    const rawCount = featureCategories.raw_sensor_features ? featureCategories.raw_sensor_features.length : 0;
                    const calcCount = featureCategories.calculated_features ? featureCategories.calculated_features.length : 0;
                    message += 'Total features: ' + featureCount + ' (' + rawCount + ' raw sensors + ' + calcCount + ' calculated)\n';
                    if (metrics.features && metrics.features.length > 0) {
                        message += 'Features: ' + metrics.features.join(', ');
                    }
                    
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                    
                    // Display training data table with all sensor categories
                    if (trainingData && Object.keys(trainingData).length > 0) {
                        // Helper function to check if a value is a valid number
                        const isValidNumber = (val) => val !== null && val !== undefined && !isNaN(val);
                        
                        let tableHtml = '<h4 style="margin-top: 1rem; margin-bottom: 0.5rem;">üìä Training Data Range</h4>';
                        tableHtml += '<table class="training-data-table">';
                        tableHtml += '<thead><tr><th>Sensor</th><th>First Value</th><th>Last Value</th><th>Delta</th></tr></thead>';
                        tableHtml += '<tbody>';
                        
                        // Sort sensors for consistent display
                        const sortedSensors = Object.keys(trainingData).sort();
                        
                        for (const sensor of sortedSensors) {
                            const sensorData = trainingData[sensor];
                            const unit = sensorData.unit || '';
                            
                            tableHtml += '<tr>';
                            tableHtml += '<td><strong>' + sensor + '</strong></td>';
                            tableHtml += '<td>' + (isValidNumber(sensorData.first) ? sensorData.first.toFixed(2) + ' ' + unit : 'N/A') + '</td>';
                            tableHtml += '<td>' + (isValidNumber(sensorData.last) ? sensorData.last.toFixed(2) + ' ' + unit : 'N/A') + '</td>';
                            
                            // Show delta for hp_kwh_total (the actual energy consumed during training)
                            if (sensor === 'hp_kwh_total' && isValidNumber(sensorData.delta)) {
                                tableHtml += '<td style="color: var(--accent-green); font-weight: bold;">' + sensorData.delta.toFixed(2) + ' ' + unit + '</td>';
                            } else if (isValidNumber(sensorData.first) && isValidNumber(sensorData.last)) {
                                const delta = sensorData.last - sensorData.first;
                                tableHtml += '<td>' + (delta >= 0 ? '+' : '') + delta.toFixed(2) + ' ' + unit + '</td>';
                            } else {
                                tableHtml += '<td>N/A</td>';
                            }
                            tableHtml += '</tr>';
                        }
                        
                        tableHtml += '</tbody></table>';
                        tableDiv.innerHTML = tableHtml;
                    }
                } else {
                    let message = '‚úó ' + (data.message || 'Training failed');
                    if (data.stats) {
                        message += '\n\nDataset stats:';
                        message += '\nTotal slots: ' + (data.stats.total_slots || 0);
                        message += '\nValid slots: ' + (data.stats.valid_slots || 0);
                    }
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function getModelStatus() {
            const btn = document.getElementById('statusBtn');
            const statusDiv = document.getElementById('modelStatus');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Checking model status...';
            
            try {
                const response = await fetch('api/model/status');
                const data = await response.json();
                
                if (data.status === 'available') {
                    let message = '‚úì Model is available\n\n';
                    message += 'Training timestamp: ' + (data.training_timestamp || 'Unknown') + '\n';
                    if (data.features && data.features.length > 0) {
                        message += 'Features: ' + data.features.join(', ');
                    }
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = message;
                } else {
                    statusDiv.className = 'status-message info';
                    statusDiv.textContent = '‚ÑπÔ∏è ' + (data.message || 'No model available');
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadSensorInfo() {
            const btn = document.getElementById('loadSensorsBtn');
            const statusDiv = document.getElementById('sensorInfoStatus');
            const tableDiv = document.getElementById('sensorInfoTable');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading sensor information...';
            tableDiv.innerHTML = '';
            
            try {
                const response = await fetch('api/sensors/info');
                const data = await response.json();
                
                if (response.ok && data.sensors && data.sensors.length > 0) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Found ${data.count} sensors`;
                    
                    let html = '<table class="sensor-table"><thead><tr>';
                    html += '<th>Entity ID</th><th>First Timestamp</th><th>Last Timestamp</th><th>Sample Count</th>';
                    html += '</tr></thead><tbody>';
                    
                    data.sensors.forEach(sensor => {
                        html += `<tr>`;
                        html += `<td>${sensor.entity_id}</td>`;
                        html += `<td>${sensor.first_timestamp || 'N/A'}</td>`;
                        html += `<td>${sensor.last_timestamp || 'N/A'}</td>`;
                        html += `<td>${sensor.sample_count.toLocaleString()}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += '</tbody></table>';
                    tableDiv.innerHTML = html;
                } else if (response.ok) {
                    statusDiv.className = 'status-message info';
                    statusDiv.textContent = '‚ÑπÔ∏è No sensors found in database';
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadScenarioExample() {
            const btn = document.getElementById('loadScenarioExampleBtn');
            const statusDiv = document.getElementById('scenarioStatus');
            const textarea = document.getElementById('scenarioInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading example...';
            
            try {
                const response = await fetch('api/examples/scenario');
                const data = await response.json();
                
                if (response.ok) {
                    textarea.value = JSON.stringify(data.example, null, 2);
                    // Clear historical data when loading example
                    currentHistoricalData = null;
                    document.getElementById('historicalDaySelect').value = '';
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.description;
                    if (!data.model_available) {
                        statusDiv.textContent += '\n‚ö†Ô∏è Model not available - train the model first';
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function runScenarioPrediction() {
            const btn = document.getElementById('runScenarioPredictionBtn');
            const statusDiv = document.getElementById('scenarioStatus');
            const resultDiv = document.getElementById('scenarioResult');
            const textarea = document.getElementById('scenarioInput');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Running prediction...';
            resultDiv.innerHTML = '';
            
            try {
                const requestData = JSON.parse(textarea.value);
                
                const response = await fetch('api/predictions/scenario', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Store prediction data for later storage
                    lastPredictionData = data;
                    document.getElementById('storePredictionBtn').style.display = 'inline-block';
                    
                    statusDiv.className = 'status-message success';
                    let statusText = '‚úì Prediction completed successfully - ' + data.slots_count + ' timeslots processed';
                    if (data.model_info && data.model_info.two_step_prediction) {
                        statusText += ' (using two-step prediction)';
                    }
                    if (currentHistoricalData) {
                        statusText += ' (comparing with actual historical data)';
                    }
                    statusDiv.textContent = statusText;
                    
                    const predictions = data.predictions;
                    const predValues = predictions.map(p => p.predicted_kwh);
                    
                    // Helper function to extract hour key from timestamp
                    function getHourKey(timestamp) {
                        if (!timestamp || typeof timestamp !== 'string') return null;
                        const tIndex = timestamp.indexOf('T');
                        if (tIndex === -1) return null;
                        const timePart = timestamp.substring(tIndex + 1);
                        if (timePart.length < 5) return null;
                        return timePart.substring(0, 5);
                    }
                    
                    // Get actual values if historical data is available
                    let actualValues = [];
                    let hasComparison = false;
                    if (currentHistoricalData && currentHistoricalData.length > 0) {
                        // Build lookup by hour for comparison
                        const actualByHour = {};
                        currentHistoricalData.forEach(h => {
                            const hourKey = getHourKey(h.timestamp);
                            if (hourKey !== null) {
                                actualByHour[hourKey] = h.actual_heating_kwh;
                            }
                        });
                        
                        predictions.forEach(p => {
                            const hourKey = getHourKey(p.timestamp);
                            actualValues.push(hourKey !== null && actualByHour[hourKey] !== undefined ? actualByHour[hourKey] : null);
                        });
                        hasComparison = actualValues.some(v => v !== null && v !== undefined);
                    }
                    
                    const maxPred = Math.max(...predValues, 0.1);
                    const filteredActuals = actualValues.filter(v => v !== null && v !== undefined);
                    const maxActual = hasComparison && filteredActuals.length > 0 ? Math.max(...filteredActuals, 0.1) : 0;
                    const maxVal = Math.max(maxPred, maxActual, 0.1);
                    
                    // Create bar chart with comparison if available
                    let chartHtml = '<div class="chart-container"><h4 style="margin-top:0">Hourly Heating Demand' + (hasComparison ? ' (Predicted vs Actual)' : '') + '</h4>';
                    if (hasComparison) {
                        chartHtml += '<div style="margin-bottom: 0.5rem; font-size: 0.85rem;"><span style="color: #3b82f6;">‚ñ† Predicted</span> <span style="color: #22c55e; margin-left: 1rem;">‚ñ† Actual</span></div>';
                    }
                    chartHtml += '<div class="chart-wrapper">';
                    predictions.forEach((pred, idx) => {
                        const predHeight = (pred.predicted_kwh / maxVal) * 100;
                        const width = Math.max(100 / predictions.length / (hasComparison ? 2 : 1) - 1, 3);
                        chartHtml += `<div class="bar" style="height: ${predHeight}%; width: ${width}%; background: #3b82f6;" title="${pred.timestamp}: ${pred.predicted_kwh.toFixed(3)} kWh (predicted)"></div>`;
                        
                        if (hasComparison && actualValues[idx] !== null && actualValues[idx] !== undefined) {
                            const actualHeight = (actualValues[idx] / maxVal) * 100;
                            chartHtml += `<div class="bar" style="height: ${actualHeight}%; width: ${width}%; background: #22c55e;" title="${pred.timestamp}: ${actualValues[idx].toFixed(3)} kWh (actual)"></div>`;
                        }
                    });
                    chartHtml += '</div>';
                    chartHtml += '<div class="chart-labels">';
                    if (predictions.length >= 4) {
                        const step = Math.floor(predictions.length / 4);
                        chartHtml += `<span>${predictions[0].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step*2].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[step*3].timestamp.split('T')[1]}</span>`;
                        chartHtml += `<span>${predictions[predictions.length-1].timestamp.split('T')[1]}</span>`;
                    }
                    chartHtml += '</div></div>';
                    
                    // Create table with comparison column if available
                    if (hasComparison) {
                        chartHtml += '<table class="results-table"><thead><tr><th>Timestamp</th><th>Predicted kWh</th><th>Actual kWh</th><th>Œî (kWh)</th><th>Œî (%)</th></tr></thead><tbody>';
                        let totalActual = 0;
                        let totalDelta = 0;
                        let countCompared = 0;
                        predictions.forEach((pred, idx) => {
                            const actual = actualValues[idx];
                            const hasActual = actual !== null && actual !== undefined;
                            const delta = hasActual ? pred.predicted_kwh - actual : null;
                            const deltaPct = hasActual && actual > 0.01 ? (delta / actual * 100) : null;
                            
                            if (hasActual) {
                                totalActual += actual;
                                totalDelta += Math.abs(delta);
                                countCompared++;
                            }
                            
                            const deltaClass = delta !== null ? (delta > 0 ? 'color: #f87171;' : 'color: #4ade80;') : '';
                            
                            chartHtml += `<tr>`;
                            chartHtml += `<td>${pred.timestamp}</td>`;
                            chartHtml += `<td>${pred.predicted_kwh.toFixed(4)}</td>`;
                            chartHtml += `<td>${hasActual ? actual.toFixed(4) : '-'}</td>`;
                            chartHtml += `<td style="${deltaClass}">${delta !== null ? (delta > 0 ? '+' : '') + delta.toFixed(4) : '-'}</td>`;
                            chartHtml += `<td style="${deltaClass}">${deltaPct !== null ? (deltaPct > 0 ? '+' : '') + deltaPct.toFixed(1) + '%' : '-'}</td>`;
                            chartHtml += `</tr>`;
                        });
                        chartHtml += '</tbody></table>';
                        
                        // Summary statistics
                        const mae = countCompared > 0 ? totalDelta / countCompared : 0;
                        const mape = countCompared > 0 && totalActual > 0 ? (totalDelta / totalActual * 100) : null;
                        
                        chartHtml += `<div style="display: flex; gap: 2rem; margin-top: 1rem;">`;
                        chartHtml += `<div class="total-kwh">Predicted Total: ${data.total_kwh.toFixed(4)} kWh</div>`;
                        chartHtml += `<div class="total-kwh" style="color: #22c55e;">Actual Total: ${totalActual.toFixed(4)} kWh</div>`;
                        chartHtml += `</div>`;
                        chartHtml += `<div style="margin-top: 0.5rem; color: #9ca3af; font-size: 0.9rem;">`;
                        chartHtml += `Mean Absolute Error: ${mae.toFixed(4)} kWh`;
                        if (mape !== null) {
                            chartHtml += ` | MAPE: ${mape.toFixed(1)}%`;
                        }
                        chartHtml += `</div>`;
                    } else {
                        // Check if using two-step prediction (has is_active field)
                        const isTwoStep = data.model_info && data.model_info.two_step_prediction;
                        
                        if (isTwoStep) {
                            chartHtml += '<table class="results-table"><thead><tr><th>Timestamp</th><th>Predicted kWh</th><th>Active</th><th>Activity Prob.</th></tr></thead><tbody>';
                            predictions.forEach(pred => {
                                const activeIcon = pred.is_active ? 'üî•' : '‚ùÑÔ∏è';
                                const activeText = pred.is_active ? 'Active' : 'Inactive';
                                const probPct = (pred.activity_probability * 100).toFixed(1);
                                chartHtml += `<tr><td>${pred.timestamp}</td><td>${pred.predicted_kwh.toFixed(4)}</td><td>${activeIcon} ${activeText}</td><td>${probPct}%</td></tr>`;
                            });
                            chartHtml += '</tbody></table>';
                            
                            // Show two-step summary
                            if (data.summary) {
                                chartHtml += `<div style="margin-top: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">`;
                                chartHtml += `<div style="font-size: 0.9rem; color: var(--text-secondary);">`;
                                chartHtml += `üî• Active hours: ${data.summary.active_hours} | ‚ùÑÔ∏è Inactive hours: ${data.summary.inactive_hours}`;
                                chartHtml += `</div>`;
                                chartHtml += `</div>`;
                            }
                            
                            chartHtml += `<div class="total-kwh">Total Consumption: ${data.total_kwh.toFixed(4)} kWh</div>`;
                        } else {
                            chartHtml += '<table class="results-table"><thead><tr><th>Timestamp</th><th>Predicted kWh</th></tr></thead><tbody>';
                            predictions.forEach(pred => {
                                chartHtml += `<tr><td>${pred.timestamp}</td><td>${pred.predicted_kwh.toFixed(4)}</td></tr>`;
                            });
                            chartHtml += '</tbody></table>';
                            chartHtml += `<div class="total-kwh">Total Consumption: ${data.total_kwh.toFixed(4)} kWh</div>`;
                        }
                    }
                    
                    resultDiv.innerHTML = chartHtml;
                } else {
                    statusDiv.className = 'status-message error';
                    let message = '‚úó ' + data.message;
                    if (data.errors && data.errors.length > 0) {
                        message += '\n\nErrors:\n' + data.errors.join('\n');
                    }
                    if (data.required_fields) {
                        message += '\n\nRequired fields: ' + data.required_fields.join(', ');
                    }
                    statusDiv.textContent = message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        // =============================================================================
        // SENSOR CONFIGURATION FUNCTIONS
        // =============================================================================

        async function loadSensorConfig() {
            const btn = document.getElementById('loadSensorsBtn');
            const statusDiv = document.getElementById('sensorConfigStatus');
            const summaryDiv = document.getElementById('sensorConfigSummary');
            const contentDiv = document.getElementById('sensorConfigContent');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading sensor configuration...';
            
            try {
                const response = await fetch('api/sensors/category_config');
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Configuration loaded: ${data.config.enabled_sensor_count} sensors enabled`;
                    
                    // Update summary
                    summaryDiv.style.display = 'block';
                    document.getElementById('coreSensorCount').textContent = data.config.core_sensor_count;
                    document.getElementById('expSensorCount').textContent = data.config.experimental_sensor_count;
                    document.getElementById('enabledSensorCount').textContent = data.config.enabled_sensor_count;
                    
                    // Build UI grouped by sensor type
                    let html = '';
                    const typeOrder = ['usage', 'weather', 'indoor', 'heating'];
                    const typeIcons = {
                        'usage': '‚ö°',
                        'weather': 'üå§Ô∏è',
                        'indoor': 'üè†',
                        'heating': 'üî•'
                    };
                    const typeDescriptions = {
                        'usage': 'Energy consumption sensors (required for training)',
                        'weather': 'Weather and outdoor condition sensors',
                        'indoor': 'Indoor climate and setpoint sensors',
                        'heating': 'Heating system monitoring sensors'
                    };
                    
                    typeOrder.forEach(sensorType => {
                        const sensors = data.sensors_by_type[sensorType] || [];
                        if (sensors.length === 0) return;
                        
                        html += '<div class="feature-category">';
                        html += `<div class="feature-category-title">${typeIcons[sensorType] || 'üìå'} ${sensorType.charAt(0).toUpperCase() + sensorType.slice(1)}</div>`;
                        html += `<div class="feature-description" style="margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">${typeDescriptions[sensorType] || ''}</div>`;
                        html += '<div class="feature-list">';
                        
                        sensors.forEach(s => {
                            const itemClass = s.is_core ? 'core' : (s.enabled ? 'experimental' : 'experimental disabled');
                            const badgeClass = s.is_core ? 'core' : 'experimental';
                            const badgeText = s.is_core ? 'CORE' : 'EXPERIMENTAL';
                            const checked = s.enabled ? 'checked' : '';
                            const toggleDisabled = s.is_core ? 'disabled' : '';
                            
                            // Safely escape values - category names from server are alphanumeric only
                            // All other values are escaped for HTML special characters
                            const safeCategoryName = s.category_name.replace(/[^a-zA-Z0-9_]/g, '');
                            const escapeHtml = (str) => (str || '')
                                .replace(/&/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;')
                                .replace(/"/g, '&quot;')
                                .replace(/'/g, '&#39;');
                            const safeDisplayName = escapeHtml(s.display_name);
                            const safeDesc = escapeHtml(s.description);
                            const safeUnit = escapeHtml(s.unit);
                            const safeEntityId = escapeHtml(s.entity_id);
                            
                            html += `<div class="feature-item ${itemClass}">`;
                            html += `<div class="feature-toggle"><input type="checkbox" ${checked} ${toggleDisabled} data-sensor="${safeCategoryName}" onchange="toggleSensor('${safeCategoryName}', this.checked)"></div>`;
                            html += `<div class="feature-info" style="flex: 1;">`;
                            html += `<div class="feature-name">${safeDisplayName}<span class="feature-badge ${badgeClass}">${badgeText}</span></div>`;
                            html += `<div class="feature-description">${safeDesc}</div>`;
                            html += `<div class="feature-meta">Unit: ${safeUnit}</div>`;
                            html += `<div style="margin-top: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">`;
                            html += `<label style="color: var(--text-secondary); font-size: 0.85rem;">Entity ID:</label>`;
                            html += `<input type="text" id="entity_${safeCategoryName}" value="${safeEntityId}" placeholder="sensor.entity_id" style="flex: 1; max-width: 300px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); padding: 0.35rem 0.5rem; font-size: 0.85rem;">`;
                            html += `<button class="action-btn secondary" style="padding: 0.35rem 0.75rem; font-size: 0.85rem;" onclick="saveSensorEntity('${safeCategoryName}')">Save</button>`;
                            html += `</div>`;
                            html += `</div>`;
                            html += `</div>`;
                        });
                        
                        html += '</div>'; // feature-list
                        html += '</div>'; // feature-category
                    });
                    
                    contentDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + (data.message || 'Unknown error');
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function toggleSensor(categoryName, enabled) {
            const statusDiv = document.getElementById('sensorConfigStatus');
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = `${enabled ? 'Enabling' : 'Disabling'} sensor...`;
            
            try {
                const response = await fetch('api/sensors/toggle', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ category_name: categoryName, enabled: enabled })
                });
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    // Reload to update counts
                    loadSensorConfig();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + (data.message || 'Failed to toggle sensor');
                    // Revert checkbox
                    const checkbox = document.querySelector(`input[data-sensor="${categoryName}"]`);
                    if (checkbox) checkbox.checked = !enabled;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        async function saveSensorEntity(categoryName) {
            const statusDiv = document.getElementById('sensorConfigStatus');
            const inputId = `entity_${categoryName}`;
            const input = document.getElementById(inputId);
            const entityId = input ? input.value.trim() : '';
            
            if (!entityId) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Entity ID cannot be empty';
                return;
            }
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Saving entity ID...';
            
            try {
                const response = await fetch('api/sensors/set_entity', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ category_name: categoryName, entity_id: entityId })
                });
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + (data.message || 'Failed to save entity ID');
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        async function loadFeatureConfigAuto() {
            const statusDiv = document.getElementById('featureConfigStatus');
            const contentDiv = document.getElementById('featureConfigContent');
            const sensorContainer = document.getElementById('sensorCardsContainer');
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading configuration...';
            
            try {
                // Load special cards, sensor cards, and config in parallel
                const [specialResponse, sensorResponse, configResponse] = await Promise.all([
                    fetch('api/features/special_cards'),
                    fetch('api/features/sensor_cards'),
                    fetch('api/features/config')
                ]);
                
                const specialData = await specialResponse.json();
                const sensorData = await sensorResponse.json();
                const configData = await configResponse.json();
                
                if (specialResponse.ok && sensorResponse.ok && configResponse.ok) {
                    // Count features
                    const coreCount = configData.config.core_feature_count;
                    const activeCount = configData.config.active_feature_count;
                    const experimentalCount = activeCount - coreCount;
                    
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Configuration loaded: ${activeCount} active features (${coreCount} core + ${experimentalCount} experimental)`;
                    
                    // Build UI for main content (stats, timezone, special cards)
                    let html = '';
                    
                    // Feature stats
                    html += '<div class="feature-stats">';
                    html += `<div class="feature-stat"><div class="feature-stat-value">${coreCount}</div><div class="feature-stat-label">Core Features</div></div>`;
                    html += `<div class="feature-stat"><div class="feature-stat-value">${activeCount}</div><div class="feature-stat-label">Active Features</div></div>`;
                    html += '</div>';
                    
                    // Timezone configuration
                    html += '<div class="timezone-config">';
                    html += '<label for="timezoneSelect">üïê Timezone for hour_of_day:</label>';
                    html += `<select id="timezoneSelect" onchange="updateTimezone(this.value)">`;
                    const commonTimezones = [
                        'Europe/Amsterdam', 'Europe/London', 'Europe/Paris', 'Europe/Berlin',
                        'America/New_York', 'America/Chicago', 'America/Denver', 'America/Los_Angeles',
                        'Asia/Tokyo', 'Asia/Shanghai', 'Australia/Sydney', 'UTC'
                    ];
                    commonTimezones.forEach(tz => {
                        const selected = tz === configData.config.timezone ? 'selected' : '';
                        html += `<option value="${tz}" ${selected}>${tz}</option>`;
                    });
                    html += '</select>';
                    html += '</div>';
                    
                    // Special Cards (Time/Date and kWh - always visible)
                    specialData.cards.forEach(card => {
                        html += '<div class="feature-category">';
                        html += `<div class="feature-category-title">${card.name}</div>`;
                        html += `<p class="example-description" style="margin: 0.5rem 0;">${card.description}</p>`;
                        html += '<div class="feature-list">';
                        
                        card.features.forEach(f => {
                            const itemClass = f.is_core ? 'core' : (f.enabled ? 'experimental' : 'experimental disabled');
                            const badgeClass = f.is_core ? 'core' : 'experimental';
                            const badgeText = f.is_core ? 'CORE' : 'EXPERIMENTAL';
                            const checked = f.enabled ? 'checked' : '';
                            
                            const safeName = f.name.replace(/[^a-zA-Z0-9_]/g, '');
                            const safeDesc = f.description.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const safeUnit = f.unit.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            
                            html += `<div class="feature-item ${itemClass}">`;
                            html += `<div class="feature-toggle"><input type="checkbox" ${checked} data-feature="${safeName}" onchange="toggleFeatureAuto(this.dataset.feature, this.checked)"></div>`;
                            html += `<div class="feature-info">`;
                            html += `<div class="feature-name">${safeName} <span class="feature-badge ${badgeClass}">${badgeText}</span></div>`;
                            html += `<div class="feature-description">${safeDesc}</div>`;
                            html += `<div class="feature-meta">Unit: ${safeUnit}</div>`;
                            html += `</div>`;
                            html += `</div>`;
                        });
                        
                        html += '</div>';
                        html += '</div>';
                    });
                    
                    contentDiv.innerHTML = html;
                    
                    // Build sensor cards HTML (hidden by default, shown on button click)
                    let sensorHtml = '';
                    sensorData.sensor_cards.forEach(sensor => {
                        sensorHtml += '<div class="feature-category">';
                        sensorHtml += `<div class="feature-category-title">üå°Ô∏è ${sensor.display_name}</div>`;
                        sensorHtml += '<div class="feature-list">';
                        
                        sensor.features.forEach(f => {
                            const itemClass = f.is_core ? 'core' : (f.enabled ? 'experimental' : 'experimental disabled');
                            const badgeClass = f.is_core ? 'core' : 'experimental';
                            const badgeText = f.is_core ? 'CORE' : 'EXPERIMENTAL';
                            const checked = f.enabled ? 'checked' : '';
                            
                            const safeName = f.name.replace(/[^a-zA-Z0-9_]/g, '');
                            const safeDesc = f.description.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const safeUnit = f.unit.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            
                            sensorHtml += `<div class="feature-item ${itemClass}">`;
                            sensorHtml += `<div class="feature-toggle"><input type="checkbox" ${checked} data-feature="${safeName}" onchange="toggleFeatureAuto(this.dataset.feature, this.checked)"></div>`;
                            sensorHtml += `<div class="feature-info">`;
                            sensorHtml += `<div class="feature-name">${safeName} <span class="feature-badge ${badgeClass}">${badgeText}</span></div>`;
                            sensorHtml += `<div class="feature-description">${safeDesc}</div>`;
                            sensorHtml += `<div class="feature-meta">Unit: ${safeUnit}${f.time_window !== 'none' ? ' | Window: ' + f.time_window : ''}</div>`;
                            sensorHtml += `</div>`;
                            sensorHtml += `</div>`;
                        });
                        
                        sensorHtml += '</div>';
                        sensorHtml += '</div>';
                    });
                    
                    sensorContainer.innerHTML = sensorHtml;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error loading configuration';
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }
        
        
        function toggleSensorCards() {
            const container = document.getElementById('sensorCardsContainer');
            const btn = document.getElementById('showSensorCardsBtn');
            
            // Toggle visibility
            if (container.style.display === 'none') {
                container.style.display = 'block';
                btn.textContent = 'üìä Hide Sensor Cards';
            } else {
                container.style.display = 'none';
                btn.textContent = 'üìä Show Sensor Cards';
            }
        }
        
        async function toggleFeatureAuto(featureName, enabled) {
            const statusDiv = document.getElementById('featureConfigStatus');
            
            try {
                const response = await fetch('api/features/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        feature_name: featureName,
                        enabled: enabled
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    // Reload to update stats
                    setTimeout(() => loadFeatureConfigAuto(), 500);
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    // Reload to restore checkbox state
                    setTimeout(() => loadFeatureConfigAuto(), 500);
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                setTimeout(() => loadFeatureConfigAuto(), 500);
            }
        }

        async function loadFeatureConfig() {
            const statusDiv = document.getElementById('featureConfigStatus');
            const contentDiv = document.getElementById('featureConfigContent');
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading feature configuration...';
            
            try {
                const response = await fetch('api/features/config');
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Configuration loaded: ${data.config.active_feature_count} active features (${data.config.core_feature_count} core + ${data.config.active_feature_count - data.config.core_feature_count} experimental)`;
                    
                    // Build UI
                    let html = '';
                    
                    // Feature stats
                    html += '<div class="feature-stats">';
                    html += `<div class="feature-stat"><div class="feature-stat-value">${data.config.core_feature_count}</div><div class="feature-stat-label">Core Features</div></div>`;
                    html += `<div class="feature-stat"><div class="feature-stat-value">${data.config.active_feature_count}</div><div class="feature-stat-label">Active Features</div></div>`;
                    html += '</div>';
                    
                    // Timezone configuration
                    html += '<div class="timezone-config">';
                    html += '<label for="timezoneSelect">üïê Timezone for hour_of_day:</label>';
                    html += `<select id="timezoneSelect" onchange="updateTimezone(this.value)">`;
                    const commonTimezones = [
                        'Europe/Amsterdam', 'Europe/London', 'Europe/Paris', 'Europe/Berlin',
                        'America/New_York', 'America/Chicago', 'America/Denver', 'America/Los_Angeles',
                        'Asia/Tokyo', 'Asia/Shanghai', 'Australia/Sydney', 'UTC'
                    ];
                    commonTimezones.forEach(tz => {
                        const selected = tz === data.config.timezone ? 'selected' : '';
                        html += `<option value="${tz}" ${selected}>${tz}</option>`;
                    });
                    html += '</select>';
                    html += '</div>';
                    
                    // Category order
                    const categoryOrder = ['weather', 'indoor', 'control', 'usage', 'time'];
                    const categoryIcons = {
                        'weather': 'üå§Ô∏è',
                        'indoor': 'üè†',
                        'control': 'üéõÔ∏è',
                        'usage': '‚ö°',
                        'time': 'üïê'
                    };
                    
                    // Features by category
                    categoryOrder.forEach(category => {
                        const features = data.features[category] || [];
                        if (features.length === 0) return;
                        
                        html += '<div class="feature-category">';
                        html += `<div class="feature-category-title">${categoryIcons[category] || 'üìå'} ${category.charAt(0).toUpperCase() + category.slice(1)}</div>`;
                        html += '<div class="feature-list">';
                        
                        features.forEach(f => {
                            const itemClass = f.is_core ? 'core' : (f.enabled ? 'experimental' : 'experimental disabled');
                            const badgeClass = f.is_core ? 'core' : 'experimental';
                            const badgeText = f.is_core ? 'CORE' : 'EXPERIMENTAL';
                            const checked = f.enabled ? 'checked' : '';
                            const disabled = f.is_core ? 'disabled' : '';
                            
                            // Escape feature name for safety (feature names are alphanumeric with underscores)
                            const safeName = f.name.replace(/[^a-zA-Z0-9_]/g, '');
                            const safeDesc = f.description.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            const safeUnit = f.unit.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                            
                            html += `<div class="feature-item ${itemClass}">`;
                            html += `<div class="feature-toggle"><input type="checkbox" ${checked} ${disabled} data-feature="${safeName}" onchange="toggleFeature(this.dataset.feature, this.checked)"></div>`;
                            html += `<div class="feature-info">`;
                            html += `<div class="feature-name">${safeName}<span class="feature-badge ${badgeClass}">${badgeText}</span></div>`;
                            html += `<div class="feature-description">${safeDesc}</div>`;
                            html += `<div class="feature-meta">Unit: ${safeUnit}${f.time_window !== 'none' ? ' | Window: ' + f.time_window : ''}</div>`;
                            html += `</div>`;
                            html += `</div>`;
                        });
                        
                        html += '</div>';
                        html += '</div>';
                    });
                    
                    contentDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        async function toggleFeature(featureName, enabled) {
            const statusDiv = document.getElementById('featureConfigStatus');
            
            try {
                const response = await fetch('api/features/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        feature_name: featureName,
                        enabled: enabled
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    // Reload to update stats
                    loadFeatureConfig();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    // Reload to restore checkbox state
                    loadFeatureConfig();
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                loadFeatureConfig();
            }
        }

        async function updateTimezone(timezone) {
            const statusDiv = document.getElementById('featureConfigStatus');
            
            try {
                const response = await fetch('api/features/timezone', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timezone: timezone })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    loadFeatureConfigAuto();
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                loadFeatureConfigAuto();
            }
        }

        async function loadSensorsWithStats() {
            const btn = document.getElementById('loadSensorsWithStatsBtn');
            const statusDiv = document.getElementById('featureConfigStatus');
            const contentDiv = document.getElementById('sensorsWithStatsContent');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading sensors and statistics...';
            
            try {
                const response = await fetch('api/features/sensors_with_stats');
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Loaded ${data.total_count} sensors (${data.raw_count} raw + ${data.virtual_count} virtual)`;
                    
                    // Build UI
                    let html = '<div class="feature-category">';
                    html += '<div class="feature-category-title">üìä All Sensors with Time-Based Statistics</div>';
                    html += '<div class="feature-list">';
                    
                    data.sensors.forEach(sensor => {
                        const itemClass = sensor.type === 'raw' ? 'core' : 'experimental';
                        const badgeClass = sensor.type === 'raw' ? 'core' : 'experimental';
                        const badgeText = sensor.type === 'raw' ? 'RAW SENSOR' : 'VIRTUAL SENSOR';
                        const icon = sensor.type === 'raw' ? 'üì°' : 'üîó';
                        
                        html += `<div class="feature-item ${itemClass}">`;
                        html += `<div class="feature-info">`;
                        html += `<div class="feature-name">${icon} ${sensor.display_name || sensor.name}`;
                        html += `<span class="feature-badge ${badgeClass}">${badgeText}</span></div>`;
                        
                        if (sensor.description) {
                            html += `<div class="feature-description">${sensor.description}</div>`;
                        }
                        
                        // Show enabled statistics
                        if (sensor.enabled_stats && sensor.enabled_stats.length > 0) {
                            html += `<div class="feature-meta">`;
                            html += `Enabled statistics: ${sensor.enabled_stats.join(', ')}`;
                            html += `</div>`;
                            
                            // Show generated feature names
                            if (sensor.stat_features && sensor.stat_features.length > 0) {
                                html += `<div class="feature-meta" style="font-size: 0.75rem; color: var(--text-muted);">`;
                                html += `Features: `;
                                sensor.stat_features.forEach((feat, idx) => {
                                    if (idx > 0) html += ', ';
                                    html += `<code>${feat.name}</code>`;
                                });
                                html += `</div>`;
                            }
                        } else {
                            html += `<div class="feature-meta" style="color: var(--text-muted);">`;
                            html += `No time-based statistics enabled`;
                            html += `</div>`;
                        }
                        
                        html += `</div>`;
                        html += `</div>`;
                    });
                    
                    html += '</div>';
                    html += '</div>';
                    
                    contentDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Error: ' + data.message;
                    contentDiv.innerHTML = '';
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                contentDiv.innerHTML = '';
            } finally {
                btn.disabled = false;
            }
        }

        // =============================================================================
        // WEATHER API FUNCTIONS
        // =============================================================================
        
        // Store last prediction data for storing
        let lastPredictionData = null;
        let lastPredictionSource = 'manual';
        let lastPredictionLocation = '';

        function toggleApiKeyVisibility() {
            const input = document.getElementById('weatherApiKeyInput');
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        async function loadWeatherConfig() {
            try {
                const response = await fetch('api/weather/config');
                const data = await response.json();
                
                if (response.ok) {
                    document.getElementById('weatherLocationInput').value = data.config.location || '';
                    // Don't overwrite API key if user has entered one
                    if (!document.getElementById('weatherApiKeyInput').value && data.config.has_api_key) {
                        document.getElementById('weatherApiKeyInput').placeholder = '****** (saved)';
                    }
                }
            } catch (error) {
                console.error('Error loading weather config:', error);
            }
        }

        async function saveWeatherConfig() {
            const statusDiv = document.getElementById('weatherConfigStatus');
            const btn = document.getElementById('saveWeatherConfigBtn');
            const apiKey = document.getElementById('weatherApiKeyInput').value.trim();
            const location = document.getElementById('weatherLocationInput').value.trim();
            
            if (!apiKey) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó API key is required';
                return;
            }
            if (!location) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Location is required';
                return;
            }
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Validating and saving...';
            
            try {
                const response = await fetch('api/weather/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ api_key: apiKey, location: location })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message + ' (Location: ' + data.location_name + ')';
                    // Clear the API key input and update placeholder
                    document.getElementById('weatherApiKeyInput').value = '';
                    document.getElementById('weatherApiKeyInput').placeholder = '****** (saved)';
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function testWeatherApi() {
            const statusDiv = document.getElementById('weatherConfigStatus');
            const btn = document.getElementById('testWeatherBtn');
            const apiKey = document.getElementById('weatherApiKeyInput').value.trim();
            const location = document.getElementById('weatherLocationInput').value.trim();
            
            if (!apiKey && !location) {
                // Test saved config
                statusDiv.className = 'status-message loading';
                statusDiv.textContent = 'Testing saved configuration...';
            } else if (!apiKey) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó API key is required';
                return;
            } else if (!location) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Location is required';
                return;
            }
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Testing connection...';
            
            try {
                const response = await fetch('api/weather/validate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ api_key: apiKey || '', location: location || '' })
                });
                
                const data = await response.json();
                
                if (response.ok && data.valid) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Connection successful! Location: ' + data.location_name;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + (data.message || 'Validation failed');
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadWeatherForecast() {
            const btn = document.getElementById('loadWeatherForecastBtn');
            const statusDiv = document.getElementById('scenarioStatus');
            const textarea = document.getElementById('scenarioInput');
            const targetTemp = parseFloat(document.getElementById('targetTempInput').value) || 20.0;
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading weather forecast...';
            
            try {
                const response = await fetch(`api/weather/forecast?target_temperature=${targetTemp}`);
                const data = await response.json();
                
                if (response.ok) {
                    // Format for scenario input
                    const scenarioData = { timeslots: data.scenario_timeslots };
                    textarea.value = JSON.stringify(scenarioData, null, 2);
                    
                    // Clear historical data since we're using weather
                    currentHistoricalData = null;
                    document.getElementById('historicalDaySelect').value = '';
                    
                    // Store source info for later
                    lastPredictionSource = 'weerlive';
                    lastPredictionLocation = data.location_name || '';
                    
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Loaded weather forecast for ' + data.location_name + 
                        ' (' + data.forecast_count + ' hours). Current temp: ' + 
                        (data.current_temp !== null ? data.current_temp + '¬∞C' : 'N/A');
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        // =============================================================================
        // PREDICTION STORAGE FUNCTIONS
        // =============================================================================

        async function storePrediction() {
            const statusDiv = document.getElementById('scenarioStatus');
            const btn = document.getElementById('storePredictionBtn');
            
            if (!lastPredictionData) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó No prediction to store. Run a prediction first.';
                return;
            }
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Storing prediction...';
            
            try {
                const requestData = JSON.parse(document.getElementById('scenarioInput').value);
                
                const response = await fetch('api/predictions/store', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        timeslots: requestData.timeslots || [],
                        predictions: lastPredictionData.predictions,
                        total_kwh: lastPredictionData.total_kwh,
                        source: lastPredictionSource,
                        location: lastPredictionLocation,
                        model_type: lastPredictionData.model_info?.two_step_prediction ? 'two_step' : 'single_step',
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message + ' (ID: ' + data.prediction_id + ')';
                    btn.style.display = 'none';
                    lastPredictionData = null;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadStoredPredictions() {
            const statusDiv = document.getElementById('storedPredictionsStatus');
            const listDiv = document.getElementById('storedPredictionsList');
            const btn = document.getElementById('loadStoredPredictionsBtn');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading stored predictions...';
            listDiv.innerHTML = '';
            
            try {
                const response = await fetch('api/predictions/stored');
                const data = await response.json();
                
                if (response.ok) {
                    if (data.predictions.length === 0) {
                        statusDiv.className = 'status-message info';
                        statusDiv.textContent = '‚ÑπÔ∏è No stored predictions found';
                        return;
                    }
                    
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Found ' + data.count + ' stored predictions';
                    
                    // Build table
                    let html = '<table class="results-table"><thead><tr>';
                    html += '<th>Created</th><th>Source</th><th>Location</th><th>Total kWh</th><th>Hours</th><th>Actions</th>';
                    html += '</tr></thead><tbody>';
                    
                    data.predictions.forEach(pred => {
                        const created = new Date(pred.created_at).toLocaleString();
                        html += '<tr>';
                        html += `<td>${created}</td>`;
                        html += `<td>${pred.source}</td>`;
                        html += `<td>${pred.location || '-'}</td>`;
                        html += `<td>${pred.total_kwh.toFixed(2)}</td>`;
                        html += `<td>${pred.slots_count}</td>`;
                        html += `<td>
                            <button class="action-btn secondary" style="padding: 0.25rem 0.5rem; margin: 0 0.25rem;" onclick="comparePrediction('${pred.id}')">üìä Compare</button>
                            <button class="action-btn secondary" style="padding: 0.25rem 0.5rem; margin: 0 0.25rem; background: var(--error-bg); color: var(--error-text);" onclick="deletePrediction('${pred.id}')">üóëÔ∏è</button>
                        </td>`;
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    listDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function comparePrediction(predictionId) {
            const statusDiv = document.getElementById('storedPredictionsStatus');
            const resultDiv = document.getElementById('comparisonResult');
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Comparing with actual data...';
            resultDiv.innerHTML = '';
            
            try {
                const response = await fetch(`api/predictions/stored/${predictionId}/compare`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Comparison complete. ' + data.summary.slots_compared + ' slots with actual data.';
                    
                    // Build comparison table
                    let html = '<h4 style="margin-top: 1rem;">Comparison Results</h4>';
                    html += '<table class="results-table"><thead><tr>';
                    html += '<th>Timestamp</th><th>Predicted kWh</th><th>Actual kWh</th><th>Œî (kWh)</th><th>Œî (%)</th>';
                    html += '</tr></thead><tbody>';
                    
                    data.comparison.forEach(comp => {
                        const deltaClass = comp.delta_kwh !== null ? 
                            (comp.delta_kwh > 0 ? 'color: #f87171;' : 'color: #4ade80;') : '';
                        
                        html += '<tr>';
                        html += `<td>${comp.timestamp}</td>`;
                        html += `<td>${comp.predicted_kwh.toFixed(4)}</td>`;
                        html += `<td>${comp.has_actual ? comp.actual_kwh.toFixed(4) : '-'}</td>`;
                        html += `<td style="${deltaClass}">${comp.delta_kwh !== null ? (comp.delta_kwh > 0 ? '+' : '') + comp.delta_kwh.toFixed(4) : '-'}</td>`;
                        html += `<td style="${deltaClass}">${comp.delta_pct !== null ? (comp.delta_pct > 0 ? '+' : '') + comp.delta_pct.toFixed(1) + '%' : '-'}</td>`;
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    
                    // Summary
                    html += '<div style="margin-top: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">';
                    html += '<div style="display: flex; gap: 2rem; flex-wrap: wrap;">';
                    html += `<div><strong>Total Predicted:</strong> ${data.summary.total_predicted_kwh.toFixed(2)} kWh</div>`;
                    if (data.summary.total_actual_kwh !== null) {
                        html += `<div><strong>Total Actual:</strong> ${data.summary.total_actual_kwh.toFixed(2)} kWh</div>`;
                    }
                    if (data.summary.mae_kwh !== null) {
                        html += `<div><strong>MAE:</strong> ${data.summary.mae_kwh.toFixed(4)} kWh</div>`;
                    }
                    if (data.summary.mape_pct !== null) {
                        html += `<div><strong>MAPE:</strong> ${data.summary.mape_pct.toFixed(1)}%</div>`;
                    }
                    html += `<div><strong>Slots Compared:</strong> ${data.summary.slots_compared} / ${data.comparison.length}</div>`;
                    html += '</div></div>';
                    
                    resultDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        async function deletePrediction(predictionId) {
            if (!confirm('Are you sure you want to delete this prediction?')) {
                return;
            }
            
            const statusDiv = document.getElementById('storedPredictionsStatus');
            
            try {
                const response = await fetch(`api/predictions/stored/${predictionId}`, {
                    method: 'DELETE'
                });
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì Prediction deleted';
                    loadStoredPredictions();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        // =============================================================================
        // SETTINGS OPTIMIZER FUNCTIONS
        // =============================================================================

        async function loadOptimizerConfig() {
            try {
                const response = await fetch('api/optimizer/config');
                const data = await response.json();
                
                if (response.ok && data.config) {
                    const maxWorkers = data.config.max_workers;
                    const input = document.getElementById('maxWorkersInput');
                    if (input) {
                        input.value = maxWorkers === null ? '' : maxWorkers;
                    }
                }
            } catch (error) {
                console.error('Error loading optimizer config:', error);
            }
        }

        async function saveOptimizerConfig() {
            const input = document.getElementById('maxWorkersInput');
            const statusDiv = document.getElementById('optimizerConfigStatus');
            
            const value = input.value.trim();
            const maxWorkers = value === '' ? null : parseInt(value, 10);
            
            if (maxWorkers !== null && (isNaN(maxWorkers) || maxWorkers < 0)) {
                statusDiv.textContent = '‚úó Invalid value (must be >= 0)';
                statusDiv.style.color = 'var(--error-red)';
                return;
            }
            
            try {
                const response = await fetch('api/optimizer/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ max_workers: maxWorkers })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.textContent = '‚úì Saved';
                    statusDiv.style.color = 'var(--accent-green)';
                    setTimeout(() => {
                        statusDiv.textContent = '';
                    }, 2000);
                } else {
                    statusDiv.textContent = '‚úó ' + data.message;
                    statusDiv.style.color = 'var(--error-red)';
                }
            } catch (error) {
                statusDiv.textContent = '‚úó Error: ' + error.message;
                statusDiv.style.color = 'var(--error-red)';
            }
        }

        function toggleFeatureDetails(event, resultId, features, trainSamples, valSamples, firstRowData, lastRowData) {
            // Check if details row already exists
            const detailsRowId = `features-${resultId}`;
            const existingRow = document.getElementById(detailsRowId);
            
            if (existingRow) {
                // Remove the details row if it exists
                existingRow.remove();
                return;
            }
            
            // Find the result row
            const resultRow = event.target.closest('tr');
            if (!resultRow) return;
            
            // Create new details row
            const detailsRow = document.createElement('tr');
            detailsRow.id = detailsRowId;
            detailsRow.className = 'feature-details-row';
            
            const detailsCell = document.createElement('td');
            detailsCell.colSpan = 7;  // Span all columns
            
            // Core features (15 features - always used in their configured state)
            const coreFeatures = [
                'outdoor_temp', 'wind', 'humidity', 'indoor_temp', 'target_temp',
                'outdoor_temp_avg_1h', 'outdoor_temp_avg_24h', 'indoor_temp_avg_6h', 
                'indoor_temp_avg_24h', 'target_temp_avg_6h', 'target_temp_avg_24h',
                'hour_of_day', 'is_weekend', 'is_night', 'hp_kwh_prev_1h'
            ];
            
            // Build features display
            let html = '<div class="feature-details-content">';
            html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">';
            html += '<h5 style="margin: 0;">Features Used in Training:</h5>';
            html += '<div style="color: var(--text-secondary); font-size: 0.9rem;">';
            html += `Training: <strong>${trainSamples || 0}</strong> rows | Validation: <strong>${valSamples || 0}</strong> rows`;
            html += '</div>';
            html += '</div>';
            
            // Show core features
            html += '<div style="margin-bottom: 1rem;">';
            html += '<h6 style="margin: 0 0 0.5rem 0; color: var(--accent-green); font-size: 0.9rem;">Core Features (always used):</h6>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">';
            for (const coreFeat of coreFeatures) {
                html += `<span class="feature-tag" style="background: var(--accent-green);">${coreFeat} (${trainSamples || 0} rows)</span>`;
            }
            html += '</div>';
            html += '</div>';
            
            // Show experimental features
            html += '<div>';
            html += '<h6 style="margin: 0 0 0.5rem 0; color: var(--accent-orange); font-size: 0.9rem;">Experimental Features (tested in this configuration):</h6>';
            if (features && Object.keys(features).length > 0) {
                const enabledFeatures = Object.entries(features).filter(([_, value]) => value === true);
                
                if (enabledFeatures.length > 0) {
                    html += '<div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">';
                    for (const [key, _] of enabledFeatures) {
                        html += `<span class="feature-tag" style="background: var(--accent-orange);">${key} (${trainSamples || 0} rows)</span>`;
                    }
                    html += '</div>';
                } else {
                    html += '<p style="color: var(--text-secondary); margin: 0;">None enabled (core features only)</p>';
                }
            } else {
                html += '<p style="color: var(--text-secondary); margin: 0;">None enabled (core features only)</p>';
            }
            html += '</div>';
            
            html += `<p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0.75rem 0 0 0; font-style: italic;">Total: ${coreFeatures.length} core + ${Object.values(features || {}).filter(v => v === true).length} experimental features = ${coreFeatures.length + Object.values(features || {}).filter(v => v === true).length} features used</p>`;
            
            // Display actual training data (first and last rows)
            if (firstRowData || lastRowData) {
                html += '<div style="margin-top: 1rem;">';
                html += '<h6 style="margin: 0 0 0.5rem 0; color: var(--text-primary); font-size: 0.9rem;">üìä Training Dataset Samples:</h6>';
                
                if (firstRowData) {
                    html += '<div style="margin-bottom: 0.75rem; padding: 0.5rem; background: var(--bg-secondary); border-radius: 4px; border-left: 3px solid var(--accent-green);">';
                    html += '<strong style="color: var(--accent-green);">First Row:</strong>';
                    html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.25rem; margin-top: 0.25rem; font-size: 0.8rem;">';
                    for (const [key, value] of Object.entries(firstRowData)) {
                        const displayValue = value !== null && value !== undefined ? (typeof value === 'number' ? value.toFixed(4) : value) : 'null';
                        html += `<span style="color: var(--text-secondary);"><strong>${key}:</strong> ${displayValue}</span>`;
                    }
                    html += '</div></div>';
                }
                
                if (lastRowData) {
                    html += '<div style="padding: 0.5rem; background: var(--bg-secondary); border-radius: 4px; border-left: 3px solid var(--accent-blue);">';
                    html += '<strong style="color: var(--accent-blue);">Last Row:</strong>';
                    html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.25rem; margin-top: 0.25rem; font-size: 0.8rem;">';
                    for (const [key, value] of Object.entries(lastRowData)) {
                        const displayValue = value !== null && value !== undefined ? (typeof value === 'number' ? value.toFixed(4) : value) : 'null';
                        html += `<span style="color: var(--text-secondary);"><strong>${key}:</strong> ${displayValue}</span>`;
                    }
                    html += '</div></div>';
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            detailsCell.innerHTML = html;
            detailsRow.appendChild(detailsCell);
            
            // Insert after the clicked row
            resultRow.parentNode.insertBefore(detailsRow, resultRow.nextSibling);
        }

        async function runOptimizer() {
            const btn = document.getElementById('runOptimizerBtn');
            const progressDiv = document.getElementById('optimizerProgress');
            const progressContent = document.getElementById('optimizerProgressContent');
            const logDiv = document.getElementById('optimizerLog');
            const logContent = document.getElementById('optimizerLogContent');
            const resultsTable = document.getElementById('optimizerResultsTable');
            const bestResultCard = document.getElementById('optimizerBestResultCard');
            const applyBtn = document.getElementById('applyOptimizerBtn');
            
            btn.disabled = true;
            progressDiv.style.display = 'block';
            progressContent.className = 'status-message loading';
            progressContent.textContent = 'Starting optimization... This will run in the background.';
            logContent.textContent = 'Initializing optimizer...\n';
            resultsTable.innerHTML = '<p style="color: var(--text-secondary);">Optimization in progress...</p>';
            bestResultCard.style.display = 'none';
            applyBtn.style.display = 'none';
            
            try {
                const response = await fetch('api/optimizer/run', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    progressContent.textContent = '‚è≥ Optimization running in background... Polling for updates.';
                    
                    // Start polling for status
                    const pollInterval = setInterval(async () => {
                        try {
                            const statusResponse = await fetch('api/optimizer/status');
                            const statusData = await statusResponse.json();
                            
                            if (statusData.progress) {
                                const p = statusData.progress;
                                
                                // Update log
                                if (p.log && p.log.length > 0) {
                                    logContent.textContent = p.log.join('\n');
                                    logContent.scrollTop = logContent.scrollHeight;
                                }
                                
                                // Update progress
                                if (statusData.running) {
                                    progressContent.className = 'status-message loading';
                                    progressContent.textContent = `‚è≥ Progress: ${p.completed_configurations}/${p.total_configurations}`;
                                    if (p.current_configuration) {
                                        progressContent.textContent += `\nCurrent: ${p.current_configuration} (${p.current_model_type})`;
                                    }
                                } else if (p.phase === 'complete' || p.phase === 'error') {
                                    clearInterval(pollInterval);
                                    btn.disabled = false;
                                    
                                    if (p.phase === 'complete') {
                                        progressContent.className = 'status-message success';
                                        progressContent.textContent = '‚úì Optimization complete!';
                                        
                                        // Show best result
                                        if (p.best_result) {
                                            bestResultCard.style.display = 'block';
                                            document.getElementById('optimizerBestConfig').textContent = p.best_result.config_name;
                                            document.getElementById('optimizerBestModel').textContent = p.best_result.model_type === 'two_step' ? 'Two-Step' : 'Single-Step';
                                            document.getElementById('optimizerBestMape').textContent = p.best_result.val_mape_pct !== null ? p.best_result.val_mape_pct + '%' : 'N/A';
                                        }
                                        
                                        // Load results table
                                        await loadOptimizerResultsTable();
                                    } else {
                                        progressContent.className = 'status-message error';
                                        progressContent.textContent = '‚úó Error: ' + (p.error || 'Unknown error');
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Polling error:', error);
                        }
                    }, 2000);  // Poll every 2 seconds
                } else {
                    progressContent.className = 'status-message error';
                    progressContent.textContent = '‚úó ' + (data.message || 'Failed to start optimizer');
                    btn.disabled = false;
                }
            } catch (error) {
                progressContent.className = 'status-message error';
                progressContent.textContent = '‚úó Error: ' + error.message;
                btn.disabled = false;
            }
        }


        async function checkOptimizerStatus() {
            const statusDiv = document.getElementById('optimizerStatusDisplay');
            const btn = document.getElementById('optimizerStatusBtn');
            
            btn.disabled = true;
            statusDiv.style.display = 'block';
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Checking optimizer status...';
            
            try {
                const response = await fetch('api/optimizer/status');
                const data = await response.json();
                
                if (response.ok) {
                    if (data.progress) {
                        const p = data.progress;
                        let message = `Phase: ${p.phase}\n`;
                        message += `Progress: ${p.completed_configurations}/${p.total_configurations} configurations\n`;
                        if (p.current_configuration) {
                            message += `Current: ${p.current_configuration} (${p.current_model_type})\n`;
                        }
                        if (p.best_result) {
                            message += `\nBest so far: ${p.best_result.config_name} (${p.best_result.model_type})\n`;
                            message += `Best Val MAPE: ${p.best_result.val_mape_pct}%`;
                        }
                        
                        statusDiv.className = 'status-message ' + (data.running ? 'loading' : 'info');
                        statusDiv.textContent = message;
                    } else {
                        statusDiv.className = 'status-message info';
                        statusDiv.textContent = '‚ÑπÔ∏è ' + (data.message || 'No optimization has been run yet');
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function loadOptimizerResultsTable() {
            const resultsTable = document.getElementById('optimizerResultsTable');
            const refreshBtn = document.getElementById('refreshResultsBtn');
            
            if (refreshBtn) refreshBtn.disabled = true;
            if (resultsTable) resultsTable.innerHTML = '<p style="color: var(--text-secondary);">Loading results...</p>';
            
            try {
                const response = await fetch('api/optimizer/latest');
                const data = await response.json();
                
                if (response.ok && data.run && data.run.results && data.run.results.length > 0) {
                    const results = data.run.results;
                    const maxResults = 30;
                    
                    // Sort by Val MAPE ascending
                    const sortedResults = [...results].sort((a, b) => {
                        if (a.val_mape_pct === null) return 1;
                        if (b.val_mape_pct === null) return -1;
                        return a.val_mape_pct - b.val_mape_pct;
                    });
                    
                    // Limit to top 30 results
                    const limitedResults = sortedResults.slice(0, maxResults);
                    
                    let html = '<table class="results-table"><thead><tr>';
                    html += '<th>Rank</th><th>Configuration</th><th>Model</th><th>Val MAPE (%)</th><th>Val MAE (kWh)</th><th>Val R¬≤</th><th>Status</th><th>Actions</th>';
                    html += '</tr></thead><tbody>';
                    
                    limitedResults.forEach((result, idx) => {
                        const isBest = data.run.best_result && 
                            result.config_name === data.run.best_result.config_name && 
                            result.model_type === data.run.best_result.model_type;
                        const rowStyle = isBest ? 'background: rgba(76, 175, 80, 0.2);' : '';
                        
                        // Escape JSON for HTML attribute
                        const escapedFeatures = JSON.stringify(result.experimental_features || {}).replace(/'/g, "\\'");
                        const escapedFirstRow = JSON.stringify(result.first_row_data || null).replace(/'/g, "\\'");
                        const escapedLastRow = JSON.stringify(result.last_row_data || null).replace(/'/g, "\\'");
                        
                        html += `<tr style="${rowStyle}" onclick="toggleFeatureDetails(event, ${result.id}, JSON.parse('${escapedFeatures}'), ${result.train_samples || 0}, ${result.val_samples || 0}, JSON.parse('${escapedFirstRow}'), JSON.parse('${escapedLastRow}'))">`;
                        html += `<td>${idx + 1}${isBest ? ' üëë' : ''}</td>`;
                        html += `<td>${result.config_name}</td>`;
                        html += `<td>${result.model_type === 'two_step' ? 'Two-Step' : 'Single-Step'}</td>`;
                        html += `<td>${result.val_mape_pct !== null ? result.val_mape_pct.toFixed(2) + '%' : '-'}</td>`;
                        html += `<td>${result.val_mae_kwh !== null ? result.val_mae_kwh.toFixed(4) : '-'}</td>`;
                        html += `<td>${result.val_r2 !== null ? result.val_r2.toFixed(4) : '-'}</td>`;
                        html += `<td>${result.success ? '‚úì' : '‚úó'}</td>`;
                        
                        // Add apply and select buttons
                        html += `<td onclick="event.stopPropagation();">`;
                        if (result.success && result.id) {
                            html += `<button class="action-btn secondary" style="padding: 0.25rem 0.5rem; font-size: 0.85rem; margin: 0.1rem;" onclick="applyResultById(${result.id})">Apply</button>`;
                            html += `<button class="action-btn secondary" style="padding: 0.25rem 0.5rem; font-size: 0.85rem; margin: 0.1rem;" onclick="selectForRetrain(${result.id})">Select</button>`;
                        } else {
                            html += '-';
                        }
                        html += `</td>`;
                        
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    resultsTable.innerHTML = html;
                } else {
                    resultsTable.innerHTML = '<p style="color: var(--text-secondary);">No optimization results available yet. Run the optimizer to generate results.</p>';
                }
            } catch (error) {
                resultsTable.innerHTML = '<p style="color: var(--error-text);">Error loading results: ' + error.message + '</p>';
            } finally {
                if (refreshBtn) refreshBtn.disabled = false;
            }
        }

        function selectForRetrain(resultId) {
            document.getElementById('selectedResultId').value = resultId;
            // Scroll to retrain section
            document.querySelector('#selectedResultId').scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        async function retrainFromResult() {
            const resultIdInput = document.getElementById('selectedResultId');
            const statusDiv = document.getElementById('retrainStatus');
            const btn = document.getElementById('retrainFromResultBtn');
            
            const resultId = parseInt(resultIdInput.value);
            
            if (!resultId || isNaN(resultId)) {
                statusDiv.className = 'status-message error';
                statusDiv.style.display = 'block';
                statusDiv.textContent = '‚úó Please select a valid result ID';
                return;
            }
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.style.display = 'block';
            statusDiv.textContent = 'Re-training model with selected configuration...';
            
            try {
                // First, get the result details
                const resultResponse = await fetch(`api/optimizer/runs/${resultId}`);
                if (!resultResponse.ok) {
                    throw new Error('Failed to fetch result details');
                }
                
                const resultData = await resultResponse.json();
                
                // Apply the configuration first
                const applyResponse = await fetch(`api/optimizer/apply/${resultId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enable_two_step: true })
                });
                
                const applyData = await applyResponse.json();
                
                if (!applyResponse.ok) {
                    throw new Error(applyData.message || 'Failed to apply configuration');
                }
                
                statusDiv.textContent = '‚úì Configuration applied. Now training model...\n';
                
                // Now train the model based on the model type
                const isTwoStep = resultData.run && resultData.run.results && 
                    resultData.run.results.find(r => r.id === resultId)?.model_type === 'two_step';
                
                const trainEndpoint = isTwoStep ? 'api/train/two_step_heating_demand' : 'api/train/heating_demand';
                
                const trainResponse = await fetch(trainEndpoint, {
                    method: 'POST'
                });
                
                const trainData = await trainResponse.json();
                
                if (trainResponse.ok) {
                    statusDiv.className = 'status-message success';
                    let message = '‚úì Model re-trained successfully!\n\n';
                    
                    if (isTwoStep) {
                        message += 'Two-Step Model:\n';
                        message += `- Classifier Accuracy: ${trainData.classifier_metrics?.accuracy ? (trainData.classifier_metrics.accuracy * 100).toFixed(1) + '%' : 'N/A'}\n`;
                        message += `- Regressor Val MAPE: ${trainData.regressor_metrics?.val_mape_pct !== null ? trainData.regressor_metrics.val_mape_pct + '%' : 'N/A'}\n`;
                    } else {
                        message += 'Single-Step Model:\n';
                        message += `- Val MAPE: ${trainData.metrics?.val_mape_pct !== null ? trainData.metrics.val_mape_pct + '%' : 'N/A'}\n`;
                        message += `- Val MAE: ${trainData.metrics?.val_mae_kwh !== null ? trainData.metrics.val_mae_kwh.toFixed(4) + ' kWh' : 'N/A'}\n`;
                    }
                    
                    statusDiv.textContent = message;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó Training failed: ' + (trainData.message || 'Unknown error');
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function getOptimizerStatus() {
            const statusDiv = document.getElementById('optimizerStatusDisplay');
            const btn = document.getElementById('optimizerStatusBtn');
            
            if (!btn || !statusDiv) return;
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Checking optimizer status...';
            
            try {
                const response = await fetch('api/optimizer/status');
                const data = await response.json();
                
                if (response.ok) {
                    if (data.progress) {
                        const p = data.progress;
                        let message = `Phase: ${p.phase}\n`;
                        message += `Progress: ${p.completed_configurations}/${p.total_configurations} configurations\n`;
                        if (p.current_configuration) {
                            message += `Current: ${p.current_configuration} (${p.current_model_type})\n`;
                        }
                        if (p.best_result) {
                            message += `\nBest so far: ${p.best_result.config_name} (${p.best_result.model_type})\n`;
                            message += `Best Val MAPE: ${p.best_result.val_mape_pct}%`;
                        }
                        
                        statusDiv.className = 'status-message ' + (data.running ? 'loading' : 'info');
                        statusDiv.textContent = message;
                        
                        // Update log if available
                        if (p.log && p.log.length > 0) {
                            const logDiv = document.getElementById('optimizerLog');
                            const logContent = document.getElementById('optimizerLogContent');
                            logDiv.style.display = 'block';
                            logContent.textContent = p.log.join('\n');
                            logContent.scrollTop = logContent.scrollHeight;
                        }
                    } else {
                        statusDiv.className = 'status-message info';
                        statusDiv.textContent = '‚ÑπÔ∏è ' + (data.message || 'No optimization has been run yet');
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function applyOptimizerResult() {
            const statusDiv = document.getElementById('optimizerStatusDisplay');
            const btn = document.getElementById('applyOptimizerBtn');
            
            if (!confirm('Apply the best configuration found by the optimizer? This will save the new settings.')) {
                return;
            }
            
            if (!statusDiv || !btn) return;
            
            btn.disabled = true;
            statusDiv.style.display = 'block';
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Applying best configuration...';
            
            try {
                const response = await fetch('api/optimizer/apply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enable_two_step: true })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    let message = '‚úì ' + data.message + '\n\n';
                    message += 'Applied settings:\n';
                    message += `- Configuration: ${data.applied_settings.config_name}\n`;
                    message += `- Model type: ${data.applied_settings.model_type}\n`;
                    message += `- Two-step enabled: ${data.applied_settings.two_step_enabled}\n`;
                    message += `- Val MAPE: ${data.applied_settings.val_mape_pct}%`;
                    statusDiv.textContent = message;
                    
                    // Reload feature config to reflect changes
                    loadFeatureConfig();
                    loadTwoStepPredictionStatus();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            } finally {
                btn.disabled = false;
            }
        }

        async function applyResultById(resultId) {
            if (!confirm('Apply this configuration? This will save the settings.')) {
                return;
            }
            
            const statusDiv = document.getElementById('optimizerStatusDisplay');
            
            if (!statusDiv) return;
            
            statusDiv.style.display = 'block';
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Applying configuration...';
            
            try {
                const response = await fetch(`api/optimizer/apply/${resultId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enable_two_step: true })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    let message = '‚úì ' + data.message + '\n\n';
                    message += 'Applied settings:\n';
                    message += `- Configuration: ${data.applied_settings.config_name}\n`;
                    message += `- Model type: ${data.applied_settings.model_type}\n`;
                    message += `- Two-step enabled: ${data.applied_settings.two_step_enabled}\n`;
                    message += `- Val MAPE: ${data.applied_settings.val_mape_pct}%`;
                    statusDiv.textContent = message;
                    
                    // Reload feature config to reflect changes
                    loadFeatureConfig();
                    loadTwoStepPredictionStatus();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        async function loadLatestOptimizerResults() {
            const statusDiv = document.getElementById('optimizerStatusDisplay');
            const logDiv = document.getElementById('optimizerLog');
            const logContent = document.getElementById('optimizerLogContent');
            const resultsDiv = document.getElementById('optimizerResultsTable');
            const bestResultDiv = document.getElementById('optimizerBestResultCard');
            const applyBtn = document.getElementById('applyOptimizerBtn');
            
            try {
                const response = await fetch('api/optimizer/latest');
                const data = await response.json();
                
                if (response.ok && data.run) {
                    const run = data.run;
                    
                    // Show log if available
                    if (run.start_time && logDiv && logContent) {
                        logDiv.style.display = 'block';
                        const startTime = new Date(run.start_time).toLocaleString();
                        const endTime = run.end_time ? new Date(run.end_time).toLocaleString() : 'In progress';
                        logContent.textContent = `Previous run: Started ${startTime}, Ended ${endTime}\nPhase: ${run.phase}\n`;
                    }
                    
                    // Show best result if available
                    if (run.best_result && bestResultDiv) {
                        bestResultDiv.style.display = 'block';
                        const bestConfigEl = document.getElementById('optimizerBestConfig');
                        const bestModelEl = document.getElementById('optimizerBestModel');
                        const bestMapeEl = document.getElementById('optimizerBestMape');
                        
                        if (bestConfigEl) bestConfigEl.textContent = run.best_result.config_name;
                        if (bestModelEl) bestModelEl.textContent = run.best_result.model_type === 'two_step' ? 'Two-Step' : 'Single-Step';
                        if (bestMapeEl) bestMapeEl.textContent = run.best_result.val_mape_pct !== null ? run.best_result.val_mape_pct + '%' : 'N/A';
                        if (applyBtn) applyBtn.style.display = 'inline-block';
                        
                        if (statusDiv) {
                            statusDiv.className = 'status-message success';
                            statusDiv.textContent = '‚úì Previous optimization results loaded. Best Val MAPE: ' + 
                                (run.best_result.val_mape_pct !== null ? run.best_result.val_mape_pct + '%' : 'N/A');
                        }
                    }
                    
                    // Show results table
                    if (run.results && run.results.length > 0 && resultsDiv) {
                        const maxResults = 30;
                        const totalResults = run.results.length;
                        let html = '<h4 style="margin-bottom: 0.5rem;">Results from Previous Run - Top ' + Math.min(maxResults, totalResults);
                        if (totalResults > maxResults) {
                            html += ' <span style="color: var(--text-secondary); font-size: 0.85rem;">(showing ' + maxResults + ' of ' + totalResults + ')</span>';
                        }
                        html += '</h4>';
                        html += '<p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.5rem;">Click on a row to view features used</p>';
                        html += '<table class="results-table"><thead><tr>';
                        html += '<th>Configuration</th><th>Model</th><th>Val MAPE (%)</th><th>Val MAE (kWh)</th><th>Val R¬≤</th><th>Status</th><th>Action</th>';
                        html += '</tr></thead><tbody>';
                        
                        // Sort by Val MAPE ascending
                        const sortedResults = [...run.results].sort((a, b) => {
                            if (a.val_mape_pct === null) return 1;
                            if (b.val_mape_pct === null) return -1;
                            return a.val_mape_pct - b.val_mape_pct;
                        });
                        
                        // Limit to top 30 results
                        const limitedResults = sortedResults.slice(0, maxResults);
                        
                        limitedResults.forEach((result) => {
                            const isBest = run.best_result && 
                                result.config_name === run.best_result.config_name && 
                                result.model_type === run.best_result.model_type;
                            // Light green background for winner
                            const rowStyle = isBest ? 'background: rgba(76, 175, 80, 0.2);' : '';
                            
                            // Escape JSON for HTML attribute
                            const escapedFeatures = JSON.stringify(result.experimental_features || {}).replace(/'/g, "\\'");
                            const escapedFirstRow = JSON.stringify(result.first_row_data || null).replace(/'/g, "\\'");
                            const escapedLastRow = JSON.stringify(result.last_row_data || null).replace(/'/g, "\\'");
                            
                            html += `<tr style="${rowStyle}" onclick="toggleFeatureDetails(event, ${result.id}, JSON.parse('${escapedFeatures}'), ${result.train_samples || 0}, ${result.val_samples || 0}, JSON.parse('${escapedFirstRow}'), JSON.parse('${escapedLastRow}'))">`;
                            html += `<td>${result.config_name}${isBest ? ' üëë' : ''}</td>`;
                            html += `<td>${result.model_type === 'two_step' ? 'Two-Step' : 'Single-Step'}</td>`;
                            html += `<td>${result.val_mape_pct !== null ? result.val_mape_pct.toFixed(2) + '%' : '-'}</td>`;
                            html += `<td>${result.val_mae_kwh !== null ? result.val_mae_kwh.toFixed(4) : '-'}</td>`;
                            html += `<td>${result.val_r2 !== null ? result.val_r2.toFixed(4) : '-'}</td>`;
                            html += `<td>${result.success ? '‚úì' : '‚úó' + (result.error_message || 'Failed')}</td>`;
                            
                            // Add apply button for successful results (stop propagation to prevent row click)
                            if (result.success && result.id) {
                                html += `<td><button class="action-btn secondary" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;" onclick="event.stopPropagation(); applyResultById(${result.id})">Apply</button></td>`;
                            } else {
                                html += `<td>-</td>`;
                            }
                            
                            html += '</tr>';
                        });
                        
                        html += '</tbody></table>';
                        resultsDiv.innerHTML = html;
                        resultsDiv.style.display = 'block';
                    }
                } else {
                    // No previous results
                    if (statusDiv) {
                        statusDiv.className = 'status-message info';
                        statusDiv.textContent = '‚ÑπÔ∏è No previous optimization results found. Click "Run Optimizer" to start.';
                    }
                }
            } catch (error) {
                console.error('Error loading latest optimizer results:', error);
            }
        }

        // ===================================================================
        // Sensor Configuration Tab Functions
        // ===================================================================

        // Load raw sensors list
        async function loadRawSensors() {
            const statusDiv = document.getElementById('rawSensorsStatus');
            const tableDiv = document.getElementById('rawSensorsTable');
            const btn = document.getElementById('loadRawSensorsBtn');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading raw sensors...';
            
            try {
                const response = await fetch('api/sensors/category_config');
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Loaded ${data.config.enabled_sensor_count} enabled sensors`;
                    
                    // Build sensors table grouped by type
                    let html = '<div style="margin-top: 20px;">';
                    
                    const sensorTypes = data.sensors_by_type;
                    for (const [type, sensors] of Object.entries(sensorTypes)) {
                        html += `<h4 style="margin-top: 20px; margin-bottom: 10px; text-transform: capitalize;">${type} Sensors</h4>`;
                        html += '<table class="data-table">';
                        html += '<thead><tr>';
                        html += '<th>Sensor</th><th>Entity ID</th><th>Unit</th><th>Status</th><th>Actions</th>';
                        html += '</tr></thead><tbody>';
                        
                        for (const sensor of sensors) {
                            const statusBadge = sensor.is_core 
                                ? '<span style="padding: 2px 8px; background: var(--accent-green); color: white; border-radius: 3px; font-size: 0.8em;">Core</span>'
                                : (sensor.enabled 
                                    ? '<span style="padding: 2px 8px; background: var(--accent-orange); color: white; border-radius: 3px; font-size: 0.8em;">Enabled</span>'
                                    : '<span style="padding: 2px 8px; background: var(--text-muted); color: white; border-radius: 3px; font-size: 0.8em;">Disabled</span>');
                            
                            html += '<tr>';
                            html += `<td><strong>${sensor.display_name}</strong><br><small style="color: var(--text-secondary);">${sensor.description}</small></td>`;
                            html += `<td><input type="text" value="${sensor.entity_id || ''}" id="entity_${sensor.category_name}" style="width: 300px;" placeholder="sensor.example"></td>`;
                            html += `<td><input type="text" value="${sensor.unit || ''}" id="unit_${sensor.category_name}" style="width: 80px;" placeholder="Unit"></td>`;
                            html += `<td>${statusBadge}</td>`;
                            html += `<td><button class="action-btn small" onclick="saveRawSensor('${sensor.category_name}')">Save</button></td>`;
                            html += '</tr>';
                        }
                        
                        html += '</tbody></table>';
                    }
                    
                    html += '</div>';
                    tableDiv.innerHTML = html;
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    tableDiv.innerHTML = '';
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                tableDiv.innerHTML = '';
            } finally {
                btn.disabled = false;
            }
        }

        // Save a single raw sensor configuration
        async function saveRawSensor(categoryName) {
            const entityIdInput = document.getElementById(`entity_${categoryName}`);
            const unitInput = document.getElementById(`unit_${categoryName}`);
            const statusDiv = document.getElementById('rawSensorsStatus');
            
            if (!entityIdInput || !unitInput) {
                return;
            }
            
            const entityId = entityIdInput.value.trim();
            const unit = unitInput.value.trim();
            
            if (!entityId) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Entity ID is required';
                return;
            }
            
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = `Saving ${categoryName}...`;
            
            try {
                // Save entity ID
                const entityResponse = await fetch('api/sensors/set_entity', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        category_name: categoryName,
                        entity_id: entityId
                    })
                });
                
                const entityData = await entityResponse.json();
                
                if (!entityResponse.ok) {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + entityData.message;
                    return;
                }
                
                // Save unit
                const unitResponse = await fetch('api/sensors/set_unit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        category_name: categoryName,
                        unit: unit
                    })
                });
                
                const unitData = await unitResponse.json();
                
                if (unitResponse.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Saved ${categoryName}: Entity ID and unit updated`;
                    setTimeout(() => { statusDiv.textContent = ''; }, 3000);
                } else {
                    statusDiv.className = 'status-message warning';
                    statusDiv.textContent = `‚ö† Entity ID saved but unit failed: ${unitData.message}`;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        // Load virtual sensors list
        async function loadVirtualSensors() {
            const statusDiv = document.getElementById('virtualSensorsStatus');
            const tableDiv = document.getElementById('virtualSensorsTable');
            const btn = document.getElementById('loadVirtualSensorsBtn');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading virtual sensors...';
            
            try {
                const response = await fetch('api/virtual_sensors/list');
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = `‚úì Loaded ${data.count} virtual sensors`;
                    
                    if (data.count === 0) {
                        tableDiv.innerHTML = '<p style="color: var(--text-secondary); margin-top: 10px;">No virtual sensors defined yet. Click "+ Add Virtual Sensor" to create one.</p>';
                    } else {
                        // Build virtual sensors table
                        let html = '<table class="data-table" style="margin-top: 20px;">';
                        html += '<thead><tr>';
                        html += '<th>Name</th><th>Formula</th><th>Unit</th><th>Status</th><th>Actions</th>';
                        html += '</tr></thead><tbody>';
                        
                        for (const sensor of data.sensors) {
                            const statusBadge = sensor.enabled
                                ? '<span style="padding: 2px 8px; background: var(--accent-green); color: white; border-radius: 3px; font-size: 0.8em;">Enabled</span>'
                                : '<span style="padding: 2px 8px; background: var(--text-muted); color: white; border-radius: 3px; font-size: 0.8em;">Disabled</span>';
                            
                            const operationSymbol = {
                                'subtract': '-',
                                'add': '+',
                                'multiply': '√ó',
                                'divide': '√∑',
                                'average': 'avg'
                            }[sensor.operation] || sensor.operation;
                            
                            html += '<tr>';
                            html += `<td><strong>${sensor.display_name}</strong><br><small style="color: var(--text-secondary);">${sensor.description}</small></td>`;
                            html += `<td><code>${sensor.source_sensor1} ${operationSymbol} ${sensor.source_sensor2}</code></td>`;
                            html += `<td>${sensor.unit || '-'}</td>`;
                            html += `<td>${statusBadge}</td>`;
                            html += `<td>`;
                            html += `<button class="action-btn small" onclick="toggleVirtualSensor('${sensor.name}', ${!sensor.enabled})">${sensor.enabled ? 'Disable' : 'Enable'}</button>`;
                            html += `<button class="action-btn small warning" onclick="deleteVirtualSensor('${sensor.name}')">Delete</button>`;
                            html += `</td>`;
                            html += '</tr>';
                        }
                        
                        html += '</tbody></table>';
                        tableDiv.innerHTML = html;
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    tableDiv.innerHTML = '';
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                tableDiv.innerHTML = '';
            } finally {
                btn.disabled = false;
            }
        }

        // Show dialog to add a new virtual sensor
        async function showAddVirtualSensorDialog() {
            // Get available sensors for dropdowns
            const sensorsResponse = await fetch('api/sensors/category_config');
            if (!sensorsResponse.ok) {
                alert('Failed to load sensors list');
                return;
            }
            const sensorsData = await sensorsResponse.json();
            
            // Build list of all available sensors
            const allSensors = [];
            for (const [type, sensors] of Object.entries(sensorsData.sensors_by_type)) {
                for (const sensor of sensors) {
                    if (sensor.enabled) {
                        allSensors.push({
                            value: sensor.category_name,
                            label: `${sensor.display_name} (${sensor.category_name})`
                        });
                    }
                }
            }
            
            // Create dialog
            const name = prompt('Enter virtual sensor name (e.g., temp_delta):');
            if (!name) return;
            
            const displayName = prompt('Enter display name (e.g., Temperature Delta):');
            if (!displayName) return;
            
            const description = prompt('Enter description:');
            if (!description) return;
            
            const sensor1 = prompt(`Enter first sensor (available: ${allSensors.map(s => s.value).join(', ')}):`);
            if (!sensor1) return;
            
            const sensor2 = prompt(`Enter second sensor (available: ${allSensors.map(s => s.value).join(', ')}):`);
            if (!sensor2) return;
            
            const operation = prompt('Enter operation (subtract, add, multiply, divide, average):');
            if (!operation) return;
            
            const unit = prompt('Enter unit (optional):') || '';
            
            // Create virtual sensor
            const statusDiv = document.getElementById('virtualSensorsStatus');
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Creating virtual sensor...';
            
            try {
                const response = await fetch('api/virtual_sensors/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        display_name: displayName,
                        description: description,
                        source_sensor1: sensor1,
                        source_sensor2: sensor2,
                        operation: operation,
                        unit: unit
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    // Reload the list
                    await loadVirtualSensors();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        // Toggle virtual sensor enabled/disabled
        async function toggleVirtualSensor(name, enabled) {
            const statusDiv = document.getElementById('virtualSensorsStatus');
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = `${enabled ? 'Enabling' : 'Disabling'} virtual sensor...`;
            
            try {
                const response = await fetch(`api/virtual_sensors/${name}/toggle`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: enabled })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    // Reload the list
                    await loadVirtualSensors();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        // Delete virtual sensor
        async function deleteVirtualSensor(name) {
            if (!confirm(`Are you sure you want to delete virtual sensor '${name}'?`)) {
                return;
            }
            
            const statusDiv = document.getElementById('virtualSensorsStatus');
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Deleting virtual sensor...';
            
            try {
                const response = await fetch(`api/virtual_sensors/${name}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    // Reload the list
                    await loadVirtualSensors();
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
            }
        }

        // Load feature stats configuration
        async function loadFeatureStatsConfig() {
            const statusDiv = document.getElementById('featureStatsStatus');
            const tableDiv = document.getElementById('featureStatsTable');
            const btn = document.getElementById('loadFeatureStatsBtn');
            
            btn.disabled = true;
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = 'Loading feature stats configuration...';
            
            try {
                const response = await fetch('api/feature_stats/config');
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    const sensorCount = Object.keys(data.sensors).length;
                    statusDiv.textContent = `‚úì Loaded feature stats configuration for ${sensorCount} sensors`;
                    
                    if (sensorCount === 0) {
                        tableDiv.innerHTML = '<p style="color: var(--text-secondary); margin-top: 10px;">No sensors configured yet.</p>';
                    } else {
                        // Build feature stats configuration table
                        let html = '<table class="data-table" style="margin-top: 20px;">';
                        html += '<thead><tr>';
                        html += '<th>Sensor</th><th>Type</th>';
                        
                        // Add column for each stat type
                        for (const statType of data.all_stat_types) {
                            html += `<th>${statType}</th>`;
                        }
                        
                        html += '</tr></thead><tbody>';
                        
                        for (const [sensorName, sensorConfig] of Object.entries(data.sensors)) {
                            html += '<tr>';
                            html += `<td><strong>${sensorName}</strong></td>`;
                            
                            const typeBadge = sensorConfig.sensor_type === 'raw'
                                ? '<span style="padding: 2px 8px; background: var(--accent-blue); color: white; border-radius: 3px; font-size: 0.8em;">Raw</span>'
                                : '<span style="padding: 2px 8px; background: var(--accent-orange); color: white; border-radius: 3px; font-size: 0.8em;">Virtual</span>';
                            html += `<td>${typeBadge}</td>`;
                            
                            // Add checkbox for each stat type
                            for (const statType of data.all_stat_types) {
                                const isEnabled = sensorConfig.enabled_stats.includes(statType);
                                html += `<td><input type="checkbox" ${isEnabled ? 'checked' : ''} onchange="toggleFeatureStat('${sensorName}', '${statType}', this.checked)"></td>`;
                            }
                            
                            html += '</tr>';
                        }
                        
                        html += '</tbody></table>';
                        html += '<p style="margin-top: 10px; color: var(--text-secondary); font-size: 0.9em;">';
                        html += 'Check boxes to enable time-based statistics generation during resampling. ';
                        html += 'For example, enabling "avg_1h" for outdoor_temp will create "outdoor_temp_avg_1h" during resampling.';
                        html += '</p>';
                        tableDiv.innerHTML = html;
                    }
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    tableDiv.innerHTML = '';
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                tableDiv.innerHTML = '';
            } finally {
                btn.disabled = false;
            }
        }

        // Toggle a feature stat for a sensor
        async function toggleFeatureStat(sensorName, statType, enabled) {
            const statusDiv = document.getElementById('featureStatsStatus');
            statusDiv.className = 'status-message loading';
            statusDiv.textContent = `${enabled ? 'Enabling' : 'Disabling'} ${statType} for ${sensorName}...`;
            
            try {
                const response = await fetch('api/feature_stats/set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sensor_name: sensorName,
                        stat_type: statType,
                        enabled: enabled
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    statusDiv.className = 'status-message success';
                    statusDiv.textContent = '‚úì ' + data.message;
                    setTimeout(() => { statusDiv.textContent = ''; }, 2000);
                } else {
                    statusDiv.className = 'status-message error';
                    statusDiv.textContent = '‚úó ' + data.message;
                    // Reload to restore correct state
                    await loadFeatureStatsConfig();
                }
            } catch (error) {
                statusDiv.className = 'status-message error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                // Reload to restore correct state
                await loadFeatureStatsConfig();
            }
        }
    </script>
</body>
</html>
